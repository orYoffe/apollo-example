{"version":3,"file":"bundle.esm.js","sources":["../src/core/networkStatus.ts","../src/util/Observable.ts","../src/errors/ApolloError.ts","../src/core/types.ts","../src/core/ObservableQuery.ts","../src/data/mutations.ts","../src/data/queries.ts","../src/util/capitalizeFirstLetter.ts","../src/core/LocalState.ts","../src/core/QueryManager.ts","../src/data/store.ts","../src/version.ts","../src/ApolloClient.ts"],"sourcesContent":["/**\n * The current status of a queryâ€™s execution in our system.\n */\nexport enum NetworkStatus {\n  /**\n   * The query has never been run before and the query is now currently running. A query will still\n   * have this network status even if a partial data result was returned from the cache, but a\n   * query was dispatched anyway.\n   */\n  loading = 1,\n\n  /**\n   * If `setVariables` was called and a query was fired because of that then the network status\n   * will be `setVariables` until the result of that query comes back.\n   */\n  setVariables = 2,\n\n  /**\n   * Indicates that `fetchMore` was called on this query and that the query created is currently in\n   * flight.\n   */\n  fetchMore = 3,\n\n  /**\n   * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n   * and the refetch request is currently in flight.\n   */\n  refetch = 4,\n\n  /**\n   * Indicates that a polling query is currently in flight. So for example if you are polling a\n   * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n   * a poll request has been sent but not resolved.\n   */\n  poll = 6,\n\n  /**\n   * No request is in flight for this query, and no errors happened. Everything is OK.\n   */\n  ready = 7,\n\n  /**\n   * No request is in flight for this query, but one or more errors were detected.\n   */\n  error = 8,\n}\n\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */\nexport function isNetworkRequestInFlight(\n  networkStatus: NetworkStatus,\n): boolean {\n  return networkStatus < 7;\n}\n","// This simplified polyfill attempts to follow the ECMAScript Observable proposal.\n// See https://github.com/zenparsing/es-observable\nimport { Observable as LinkObservable } from 'apollo-link';\n\nexport type Subscription = ZenObservable.Subscription;\nexport type Observer<T> = ZenObservable.Observer<T>;\n\nimport $$observable from 'symbol-observable';\n\n// rxjs interopt\nexport class Observable<T> extends LinkObservable<T> {\n  public [$$observable]() {\n    return this;\n  }\n\n  public ['@@observable' as any]() {\n    return this;\n  }\n}\n","import { GraphQLError } from 'graphql';\n\nexport function isApolloError(err: Error): err is ApolloError {\n  return err.hasOwnProperty('graphQLErrors');\n}\n\n// Sets the error message on this error according to the\n// the GraphQL and network errors that are present.\n// If the error message has already been set through the\n// constructor or otherwise, this function is a nop.\nconst generateErrorMessage = (err: ApolloError) => {\n  let message = '';\n  // If we have GraphQL errors present, add that to the error message.\n  if (Array.isArray(err.graphQLErrors) && err.graphQLErrors.length !== 0) {\n    err.graphQLErrors.forEach((graphQLError: GraphQLError) => {\n      const errorMessage = graphQLError\n        ? graphQLError.message\n        : 'Error message not found.';\n      message += `GraphQL error: ${errorMessage}\\n`;\n    });\n  }\n\n  if (err.networkError) {\n    message += 'Network error: ' + err.networkError.message + '\\n';\n  }\n\n  // strip newline from the end of the message\n  message = message.replace(/\\n$/, '');\n  return message;\n};\n\nexport class ApolloError extends Error {\n  public message: string;\n  public graphQLErrors: ReadonlyArray<GraphQLError>;\n  public networkError: Error | null;\n\n  // An object that can be used to provide some additional information\n  // about an error, e.g. specifying the type of error this is. Used\n  // internally within Apollo Client.\n  public extraInfo: any;\n\n  // Constructs an instance of ApolloError given a GraphQLError\n  // or a network error. Note that one of these has to be a valid\n  // value or the constructed error will be meaningless.\n  constructor({\n    graphQLErrors,\n    networkError,\n    errorMessage,\n    extraInfo,\n  }: {\n    graphQLErrors?: ReadonlyArray<GraphQLError>;\n    networkError?: Error | null;\n    errorMessage?: string;\n    extraInfo?: any;\n  }) {\n    super(errorMessage);\n    this.graphQLErrors = graphQLErrors || [];\n    this.networkError = networkError || null;\n\n    if (!errorMessage) {\n      this.message = generateErrorMessage(this);\n    } else {\n      this.message = errorMessage;\n    }\n\n    this.extraInfo = extraInfo;\n\n    // We're not using `Object.setPrototypeOf` here as it isn't fully\n    // supported on Android (see issue #3236).\n    (this as any).__proto__ = ApolloError.prototype;\n  }\n}\n","import { FetchResult } from 'apollo-link';\nimport { DocumentNode, GraphQLError } from 'graphql';\n\nimport { QueryStoreValue } from '../data/queries';\nimport { NetworkStatus } from './networkStatus';\n\nexport type QueryListener = (\n  queryStoreValue: QueryStoreValue,\n  newData?: any,\n  forceResolvers?: boolean,\n) => void;\n\nexport type OperationVariables = { [key: string]: any };\n\nexport type PureQueryOptions = {\n  query: DocumentNode;\n  variables?: { [key: string]: any };\n  context?: any;\n};\n\nexport type ApolloQueryResult<T> = {\n  data: T;\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  stale: boolean;\n};\n\nexport enum FetchType {\n  normal = 1,\n  refetch = 2,\n  poll = 3,\n}\n\n// This is part of the public API, people write these functions in `updateQueries`.\nexport type MutationQueryReducer<T> = (\n  previousResult: Record<string, any>,\n  options: {\n    mutationResult: FetchResult<T>;\n    queryName: string | undefined;\n    queryVariables: Record<string, any>;\n  },\n) => Record<string, any>;\n\nexport type MutationQueryReducersMap<T = { [key: string]: any }> = {\n  [queryName: string]: MutationQueryReducer<T>;\n};\n\nexport interface Resolvers {\n  [key: string]: {\n    [field: string]: (\n      rootValue?: any,\n      args?: any,\n      context?: any,\n      info?: any,\n    ) => any;\n  };\n}\n","import { isEqual, tryFunctionOrLogError, cloneDeep } from 'apollo-utilities';\nimport { GraphQLError } from 'graphql';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport { Observable, Observer, Subscription } from '../util/Observable';\nimport { ApolloError } from '../errors/ApolloError';\nimport { QueryManager } from './QueryManager';\nimport { ApolloQueryResult, FetchType, OperationVariables } from './types';\nimport {\n  ModifiableWatchQueryOptions,\n  WatchQueryOptions,\n  FetchMoreQueryOptions,\n  SubscribeToMoreOptions,\n  ErrorPolicy,\n  UpdateQueryFn,\n} from './watchQueryOptions';\n\nimport { QueryStoreValue } from '../data/queries';\n\nimport { invariant } from 'ts-invariant';\n\n// XXX remove in the next breaking semver change (3.0)\n// Deprecated, use ApolloCurrentQueryResult\nexport type ApolloCurrentResult<T> = {\n  data: T | {};\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  error?: ApolloError;\n  partial?: boolean;\n};\n\nexport type ApolloCurrentQueryResult<T> = {\n  data: T | undefined;\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  error?: ApolloError;\n  partial?: boolean;\n  stale?: boolean;\n};\n\nexport interface FetchMoreOptions<\n  TData = any,\n  TVariables = OperationVariables\n> {\n  updateQuery: (\n    previousQueryResult: TData,\n    options: {\n      fetchMoreResult?: TData;\n      variables?: TVariables;\n    },\n  ) => TData;\n}\n\nexport interface UpdateQueryOptions<TVariables> {\n  variables?: TVariables;\n}\n\nexport const hasError = (\n  storeValue: QueryStoreValue,\n  policy: ErrorPolicy = 'none',\n) =>\n  storeValue &&\n  ((storeValue.graphQLErrors &&\n    storeValue.graphQLErrors.length > 0 &&\n    policy === 'none') ||\n    storeValue.networkError);\n\nexport class ObservableQuery<\n  TData = any,\n  TVariables = OperationVariables\n> extends Observable<ApolloQueryResult<TData>> {\n  public options: WatchQueryOptions<TVariables>;\n  public queryId: string;\n  /**\n   *\n   * The current value of the variables for this query. Can change.\n   */\n  public variables: TVariables;\n\n  private shouldSubscribe: boolean;\n  private isTornDown: boolean;\n  private queryManager: QueryManager<any>;\n  private observers: Observer<ApolloQueryResult<TData>>[];\n  private subscriptionHandles: Subscription[];\n\n  private lastResult: ApolloQueryResult<TData>;\n  private lastResultSnapshot: ApolloQueryResult<TData>;\n  private lastError: ApolloError;\n\n  constructor({\n    queryManager,\n    options,\n    shouldSubscribe = true,\n  }: {\n    queryManager: QueryManager<any>;\n    options: WatchQueryOptions<TVariables>;\n    shouldSubscribe?: boolean;\n  }) {\n    super((observer: Observer<ApolloQueryResult<TData>>) =>\n      this.onSubscribe(observer),\n    );\n\n    // active state\n    this.isTornDown = false;\n\n    // query information\n    this.options = options;\n    this.variables = options.variables || ({} as TVariables);\n    this.queryId = queryManager.generateQueryId();\n    this.shouldSubscribe = shouldSubscribe;\n\n    // related classes\n    this.queryManager = queryManager;\n\n    // interal data stores\n    this.observers = [];\n    this.subscriptionHandles = [];\n  }\n\n  public result(): Promise<ApolloQueryResult<TData>> {\n    const that = this;\n    return new Promise((resolve, reject) => {\n      let subscription: Subscription;\n      const observer: Observer<ApolloQueryResult<TData>> = {\n        next(result: ApolloQueryResult<TData>) {\n          resolve(result);\n\n          // Stop the query within the QueryManager if we can before\n          // this function returns.\n          //\n          // We do this in order to prevent observers piling up within\n          // the QueryManager. Notice that we only fully unsubscribe\n          // from the subscription in a setTimeout(..., 0)  call. This call can\n          // actually be handled by the browser at a much later time. If queries\n          // are fired in the meantime, observers that should have been removed\n          // from the QueryManager will continue to fire, causing an unnecessary\n          // performance hit.\n          if (!that.observers.some(obs => obs !== observer)) {\n            that.queryManager.removeQuery(that.queryId);\n          }\n\n          setTimeout(() => {\n            subscription.unsubscribe();\n          }, 0);\n        },\n        error(error: any) {\n          reject(error);\n        },\n      };\n      subscription = that.subscribe(observer);\n    });\n  }\n\n  // XXX remove in the next breaking semver change (3.0)\n  // Deprecated, use getCurrentResult()\n  public currentResult(): ApolloCurrentResult<TData> {\n    const result = this.getCurrentResult() as ApolloCurrentResult<TData>;\n    if (result.data === undefined) {\n      result.data = {};\n    }\n    return result;\n  }\n\n  /**\n   * Return the result of the query from the local cache as well as some fetching status\n   * `loading` and `networkStatus` allow to know if a request is in flight\n   * `partial` lets you know if the result from the local cache is complete or partial\n   * @return {data: Object, error: ApolloError, loading: boolean, networkStatus: number, partial: boolean}\n   */\n  public getCurrentResult(): ApolloCurrentQueryResult<TData> {\n    if (this.isTornDown) {\n      return {\n        data: this.lastError\n          ? undefined\n          : this.lastResult\n          ? this.lastResult.data\n          : undefined,\n        error: this.lastError,\n        loading: false,\n        networkStatus: NetworkStatus.error,\n      };\n    }\n\n    const queryStoreValue = this.queryManager.queryStore.get(this.queryId);\n\n    if (hasError(queryStoreValue, this.options.errorPolicy)) {\n      return {\n        data: undefined,\n        loading: false,\n        networkStatus: queryStoreValue.networkStatus,\n        error: new ApolloError({\n          graphQLErrors: queryStoreValue.graphQLErrors,\n          networkError: queryStoreValue.networkError,\n        }),\n      };\n    }\n\n    // Variables might have been added dynamically at query time, when\n    // using `@client @export(as: \"varname\")` for example. When this happens,\n    // the variables have been updated in the query store, but not updated on\n    // the original `ObservableQuery`. We'll update the observable query\n    // variables here to match, so retrieving from the cache doesn't fail.\n    if (queryStoreValue && queryStoreValue.variables) {\n      this.options.variables = Object.assign(\n        {},\n        this.options.variables,\n        queryStoreValue.variables,\n      );\n    }\n\n    const { data, partial } = this.queryManager.getCurrentQueryResult(this);\n\n    const queryLoading =\n      !queryStoreValue ||\n      queryStoreValue.networkStatus === NetworkStatus.loading;\n\n    // We need to be careful about the loading state we show to the user, to try\n    // and be vaguely in line with what the user would have seen from .subscribe()\n    // but to still provide useful information synchronously when the query\n    // will not end up hitting the server.\n    // See more: https://github.com/apollostack/apollo-client/issues/707\n    // Basically: is there a query in flight right now (modolo the next tick)?\n    const loading =\n      (this.options.fetchPolicy === 'network-only' && queryLoading) ||\n      (partial && this.options.fetchPolicy !== 'cache-only');\n\n    // if there is nothing in the query store, it means this query hasn't fired yet or it has been cleaned up. Therefore the\n    // network status is dependent on queryLoading.\n    let networkStatus: NetworkStatus;\n    if (queryStoreValue) {\n      networkStatus = queryStoreValue.networkStatus;\n    } else {\n      networkStatus = loading ? NetworkStatus.loading : NetworkStatus.ready;\n    }\n\n    const result = {\n      data,\n      loading: isNetworkRequestInFlight(networkStatus),\n      networkStatus,\n    } as ApolloQueryResult<TData>;\n\n    if (\n      queryStoreValue &&\n      queryStoreValue.graphQLErrors &&\n      this.options.errorPolicy === 'all'\n    ) {\n      result.errors = queryStoreValue.graphQLErrors;\n    }\n\n    if (!partial) {\n      this.lastResult = { ...result, stale: false };\n      this.lastResultSnapshot = cloneDeep(this.lastResult);\n    }\n\n    return { ...result, partial };\n  }\n\n  // Compares newResult to the snapshot we took of this.lastResult when it was\n  // first received.\n  public isDifferentFromLastResult(newResult: ApolloQueryResult<TData>) {\n    const { lastResultSnapshot: snapshot } = this;\n    return !(\n      snapshot &&\n      newResult &&\n      snapshot.networkStatus === newResult.networkStatus &&\n      snapshot.stale === newResult.stale &&\n      isEqual(snapshot.data, newResult.data)\n    );\n  }\n\n  // Returns the last result that observer.next was called with. This is not the same as\n  // getCurrentResult! If you're not sure which you need, then you probably need getCurrentResult.\n  public getLastResult(): ApolloQueryResult<TData> {\n    return this.lastResult;\n  }\n\n  public getLastError(): ApolloError {\n    return this.lastError;\n  }\n\n  public resetLastResults(): void {\n    delete this.lastResult;\n    delete this.lastResultSnapshot;\n    delete this.lastError;\n    this.isTornDown = false;\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public refetch(variables?: TVariables): Promise<ApolloQueryResult<TData>> {\n    const { fetchPolicy } = this.options;\n    // early return if trying to read from cache during refetch\n    if (fetchPolicy === 'cache-only') {\n      return Promise.reject(\n        new Error(\n          'cache-only fetchPolicy option should not be used together with query refetch.',\n        ),\n      );\n    }\n\n    if (!isEqual(this.variables, variables)) {\n      // update observable variables\n      this.variables = Object.assign({}, this.variables, variables);\n    }\n\n    if (!isEqual(this.options.variables, this.variables)) {\n      // Update the existing options with new variables\n      this.options.variables = Object.assign(\n        {},\n        this.options.variables,\n        this.variables,\n      );\n    }\n\n    // Override fetchPolicy for this call only\n    // only network-only and no-cache are safe to use\n    const isNetworkFetchPolicy =\n      fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';\n\n    const combinedOptions: WatchQueryOptions = {\n      ...this.options,\n      fetchPolicy: isNetworkFetchPolicy ? fetchPolicy : 'network-only',\n    };\n\n    return this.queryManager\n      .fetchQuery(this.queryId, combinedOptions, FetchType.refetch)\n      .then(result => result as ApolloQueryResult<TData>);\n  }\n\n  public fetchMore<K extends keyof TVariables>(\n    fetchMoreOptions: FetchMoreQueryOptions<TVariables, K> &\n      FetchMoreOptions<TData, TVariables>,\n  ): Promise<ApolloQueryResult<TData>> {\n    // early return if no update Query\n    invariant(fetchMoreOptions.updateQuery,\n      'updateQuery option is required. This function defines how to update the query data with the new results.',\n    );\n\n    let combinedOptions: any;\n\n    return Promise.resolve()\n      .then(() => {\n        const qid = this.queryManager.generateQueryId();\n\n        if (fetchMoreOptions.query) {\n          // fetch a new query\n          combinedOptions = fetchMoreOptions;\n        } else {\n          // fetch the same query with a possibly new variables\n          combinedOptions = {\n            ...this.options,\n            ...fetchMoreOptions,\n            variables: Object.assign(\n              {},\n              this.variables,\n              fetchMoreOptions.variables,\n            ),\n          };\n        }\n\n        combinedOptions.fetchPolicy = 'network-only';\n\n        return this.queryManager.fetchQuery(\n          qid,\n          combinedOptions as WatchQueryOptions,\n          FetchType.normal,\n          this.queryId,\n        );\n      })\n      .then(fetchMoreResult => {\n        this.updateQuery((previousResult: any) =>\n          fetchMoreOptions.updateQuery(previousResult, {\n            fetchMoreResult: fetchMoreResult.data as TData,\n            variables: combinedOptions.variables,\n          }),\n        );\n\n        return fetchMoreResult as ApolloQueryResult<TData>;\n      });\n  }\n\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  public subscribeToMore<TSubscriptionData = TData>(\n    options: SubscribeToMoreOptions<TData, TVariables, TSubscriptionData>,\n  ) {\n    const subscription = this.queryManager\n      .startGraphQLSubscription({\n        query: options.document,\n        variables: options.variables,\n      })\n      .subscribe({\n        next: (subscriptionData: { data: TSubscriptionData }) => {\n          if (options.updateQuery) {\n            this.updateQuery((previous, { variables }) =>\n              (options.updateQuery as UpdateQueryFn<\n                TData,\n                TVariables,\n                TSubscriptionData\n              >)(previous, {\n                subscriptionData,\n                variables,\n              }),\n            );\n          }\n        },\n        error: (err: any) => {\n          if (options.onError) {\n            options.onError(err);\n            return;\n          }\n          console.error('Unhandled GraphQL subscription error', err);\n        },\n      });\n\n    this.subscriptionHandles.push(subscription);\n\n    return () => {\n      const i = this.subscriptionHandles.indexOf(subscription);\n      if (i >= 0) {\n        this.subscriptionHandles.splice(i, 1);\n        subscription.unsubscribe();\n      }\n    };\n  }\n\n  // Note: if the query is not active (there are no subscribers), the promise\n  // will return null immediately.\n  public setOptions(\n    opts: ModifiableWatchQueryOptions,\n  ): Promise<ApolloQueryResult<TData>> {\n    const oldOptions = this.options;\n    this.options = Object.assign({}, this.options, opts) as WatchQueryOptions<\n      TVariables\n    >;\n\n    if (opts.pollInterval) {\n      this.startPolling(opts.pollInterval);\n    } else if (opts.pollInterval === 0) {\n      this.stopPolling();\n    }\n\n    // If fetchPolicy went from cache-only to something else, or from something else to network-only\n    const tryFetch: boolean =\n      (oldOptions.fetchPolicy !== 'network-only' &&\n        opts.fetchPolicy === 'network-only') ||\n      (oldOptions.fetchPolicy === 'cache-only' &&\n        opts.fetchPolicy !== 'cache-only') ||\n      (oldOptions.fetchPolicy === 'standby' &&\n        opts.fetchPolicy !== 'standby') ||\n      false;\n\n    return this.setVariables(\n      this.options.variables as TVariables,\n      tryFetch,\n      opts.fetchResults,\n    );\n  }\n\n  /**\n   * This is for *internal* use only. Most users should instead use `refetch`\n   * in order to be properly notified of results even when they come from cache.\n   *\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. If you want to force new results, use `refetch`.\n   *\n   * Note: the `next` callback will *not* fire if the variables have not changed\n   * or if the result is coming from cache.\n   *\n   * Note: the promise will return the old results immediately if the variables\n   * have not changed.\n   *\n   * Note: the promise will return null immediately if the query is not active\n   * (there are no subscribers).\n   *\n   * @private\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   *\n   * @param tryFetch: Try and fetch new results even if the variables haven't\n   * changed (we may still just hit the store, but if there's nothing in there\n   * this will refetch)\n   *\n   * @param fetchResults: Option to ignore fetching results when updating variables\n   */\n  public setVariables(\n    variables: TVariables,\n    tryFetch: boolean = false,\n    fetchResults = true,\n  ): Promise<ApolloQueryResult<TData>> {\n    // since setVariables restarts the subscription, we reset the tornDown status\n    this.isTornDown = false;\n\n    const newVariables = variables ? variables : this.variables;\n\n    if (isEqual(newVariables, this.variables) && !tryFetch) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      if (this.observers.length === 0 || !fetchResults) {\n        return new Promise(resolve => resolve());\n      }\n      return this.result();\n    } else {\n      this.variables = newVariables;\n      this.options.variables = newVariables;\n\n      // See comment above\n      if (this.observers.length === 0) {\n        return new Promise(resolve => resolve());\n      }\n\n      // Use the same options as before, but with new variables\n      return this.queryManager\n        .fetchQuery(this.queryId, {\n          ...this.options,\n          variables: this.variables,\n        } as WatchQueryOptions)\n        .then(result => result as ApolloQueryResult<TData>);\n    }\n  }\n\n  public updateQuery(\n    mapFn: (\n      previousQueryResult: TData,\n      options: UpdateQueryOptions<TVariables>,\n    ) => TData,\n  ): void {\n    const {\n      previousResult,\n      variables,\n      document,\n    } = this.queryManager.getQueryWithPreviousResult(this.queryId);\n\n    const newResult = tryFunctionOrLogError(() =>\n      mapFn(previousResult, { variables: variables as TVariables }),\n    );\n\n    if (newResult) {\n      this.queryManager.dataStore.markUpdateQueryResult(\n        document,\n        variables,\n        newResult,\n      );\n      this.queryManager.broadcastQueries();\n    }\n  }\n\n  public stopPolling() {\n    this.queryManager.stopPollingQuery(this.queryId);\n    this.options.pollInterval = undefined;\n  }\n\n  public startPolling(pollInterval: number) {\n    assertNotCacheFirstOrOnly(this);\n    this.options.pollInterval = pollInterval;\n    this.queryManager.startPollingQuery(this.options, this.queryId);\n  }\n\n  private onSubscribe(observer: Observer<ApolloQueryResult<TData>>) {\n    // Zen Observable has its own error function, in order to log correctly\n    // we need to declare a custom error if nothing is passed\n    if (\n      (observer as any)._subscription &&\n      (observer as any)._subscription._observer &&\n      !(observer as any)._subscription._observer.error\n    ) {\n      (observer as any)._subscription._observer.error = (\n        error: ApolloError,\n      ) => {\n        console.error('Unhandled error', error.message, error.stack);\n      };\n    }\n\n    this.observers.push(observer);\n\n    // Deliver initial result\n    if (observer.next && this.lastResult) observer.next(this.lastResult);\n    if (observer.error && this.lastError) observer.error(this.lastError);\n\n    // setup the query if it hasn't been done before\n    if (this.observers.length === 1) this.setUpQuery();\n\n    return () => {\n      this.observers = this.observers.filter(obs => obs !== observer);\n\n      if (this.observers.length === 0) {\n        this.tearDownQuery();\n      }\n    };\n  }\n\n  private setUpQuery() {\n    if (this.shouldSubscribe) {\n      this.queryManager.addObservableQuery<TData>(this.queryId, this);\n    }\n\n    if (!!this.options.pollInterval) {\n      assertNotCacheFirstOrOnly(this);\n      this.queryManager.startPollingQuery(this.options, this.queryId);\n    }\n\n    const observer: Observer<ApolloQueryResult<TData>> = {\n      next: (result: ApolloQueryResult<TData>) => {\n        this.lastResult = result;\n        this.lastResultSnapshot = cloneDeep(result);\n        this.observers.forEach(obs => obs.next && obs.next(result));\n      },\n      error: (error: ApolloError) => {\n        this.lastError = error;\n        this.observers.forEach(obs => obs.error && obs.error(error));\n      },\n    };\n\n    this.queryManager.startQuery<TData>(\n      this.queryId,\n      this.options,\n      this.queryManager.queryListenerForObserver(\n        this.queryId,\n        this.options,\n        observer,\n      ),\n    );\n  }\n\n  private tearDownQuery() {\n    this.isTornDown = true;\n    this.queryManager.stopPollingQuery(this.queryId);\n\n    // stop all active GraphQL subscriptions\n    this.subscriptionHandles.forEach(sub => sub.unsubscribe());\n    this.subscriptionHandles = [];\n\n    this.queryManager.removeObservableQuery(this.queryId);\n\n    this.queryManager.stopQuery(this.queryId);\n\n    this.observers = [];\n  }\n}\n\nfunction assertNotCacheFirstOrOnly<TData, TVariables>(\n  obsQuery: ObservableQuery<TData, TVariables>,\n) {\n  const { fetchPolicy } = obsQuery.options;\n  invariant(\n    fetchPolicy !== 'cache-first' && fetchPolicy !== 'cache-only',\n    'Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.',\n  );\n}\n","import { DocumentNode } from 'graphql';\n\nexport class MutationStore {\n  private store: { [mutationId: string]: MutationStoreValue } = {};\n\n  public getStore(): { [mutationId: string]: MutationStoreValue } {\n    return this.store;\n  }\n\n  public get(mutationId: string): MutationStoreValue {\n    return this.store[mutationId];\n  }\n\n  public initMutation(\n    mutationId: string,\n    mutation: DocumentNode,\n    variables: Object | undefined,\n  ) {\n    this.store[mutationId] = {\n      mutation,\n      variables: variables || {},\n      loading: true,\n      error: null,\n    };\n  }\n\n  public markMutationError(mutationId: string, error: Error) {\n    const mutation = this.store[mutationId];\n\n    if (!mutation) {\n      return;\n    }\n\n    mutation.loading = false;\n    mutation.error = error;\n  }\n\n  public markMutationResult(mutationId: string) {\n    const mutation = this.store[mutationId];\n\n    if (!mutation) {\n      return;\n    }\n\n    mutation.loading = false;\n    mutation.error = null;\n  }\n\n  public reset() {\n    this.store = {};\n  }\n}\n\nexport interface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Object;\n  loading: boolean;\n  error: Error | null;\n}\n","import { DocumentNode, GraphQLError, ExecutionResult } from 'graphql';\nimport { isEqual } from 'apollo-utilities';\nimport { InvariantError } from 'ts-invariant';\nimport { NetworkStatus } from '../core/networkStatus';\n\nexport type QueryStoreValue = {\n  document: DocumentNode;\n  variables: Object;\n  previousVariables?: Object | null;\n  networkStatus: NetworkStatus;\n  networkError?: Error | null;\n  graphQLErrors?: ReadonlyArray<GraphQLError>;\n  metadata: any;\n};\n\nexport class QueryStore {\n  private store: { [queryId: string]: QueryStoreValue } = {};\n\n  public getStore(): { [queryId: string]: QueryStoreValue } {\n    return this.store;\n  }\n\n  public get(queryId: string): QueryStoreValue {\n    return this.store[queryId];\n  }\n\n  public initQuery(query: {\n    queryId: string;\n    document: DocumentNode;\n    storePreviousVariables: boolean;\n    variables: Object;\n    isPoll: boolean;\n    isRefetch: boolean;\n    metadata: any;\n    fetchMoreForQueryId: string | undefined;\n  }) {\n    const previousQuery = this.store[query.queryId];\n\n    if (\n      previousQuery &&\n      previousQuery.document !== query.document &&\n      !isEqual(previousQuery.document, query.document)\n    ) {\n      // XXX we're throwing an error here to catch bugs where a query gets overwritten by a new one.\n      // we should implement a separate action for refetching so that QUERY_INIT may never overwrite\n      // an existing query (see also: https://github.com/apollostack/apollo-client/issues/732)\n      throw new InvariantError(\n        'Internal Error: may not update existing query string in store',\n      );\n    }\n\n    let isSetVariables = false;\n\n    let previousVariables: Object | null = null;\n    if (\n      query.storePreviousVariables &&\n      previousQuery &&\n      previousQuery.networkStatus !== NetworkStatus.loading\n      // if the previous query was still loading, we don't want to remember it at all.\n    ) {\n      if (!isEqual(previousQuery.variables, query.variables)) {\n        isSetVariables = true;\n        previousVariables = previousQuery.variables;\n      }\n    }\n\n    // TODO break this out into a separate function\n    let networkStatus;\n    if (isSetVariables) {\n      networkStatus = NetworkStatus.setVariables;\n    } else if (query.isPoll) {\n      networkStatus = NetworkStatus.poll;\n    } else if (query.isRefetch) {\n      networkStatus = NetworkStatus.refetch;\n      // TODO: can we determine setVariables here if it's a refetch and the variables have changed?\n    } else {\n      networkStatus = NetworkStatus.loading;\n    }\n\n    let graphQLErrors: ReadonlyArray<GraphQLError> = [];\n    if (previousQuery && previousQuery.graphQLErrors) {\n      graphQLErrors = previousQuery.graphQLErrors;\n    }\n\n    // XXX right now if QUERY_INIT is fired twice, like in a refetch situation, we just overwrite\n    // the store. We probably want a refetch action instead, because I suspect that if you refetch\n    // before the initial fetch is done, you'll get an error.\n    this.store[query.queryId] = {\n      document: query.document,\n      variables: query.variables,\n      previousVariables,\n      networkError: null,\n      graphQLErrors: graphQLErrors,\n      networkStatus,\n      metadata: query.metadata,\n    };\n\n    // If the action had a `moreForQueryId` property then we need to set the\n    // network status on that query as well to `fetchMore`.\n    //\n    // We have a complement to this if statement in the query result and query\n    // error action branch, but importantly *not* in the client result branch.\n    // This is because the implementation of `fetchMore` *always* sets\n    // `fetchPolicy` to `network-only` so we would never have a client result.\n    if (\n      typeof query.fetchMoreForQueryId === 'string' &&\n      this.store[query.fetchMoreForQueryId]\n    ) {\n      this.store[query.fetchMoreForQueryId].networkStatus =\n        NetworkStatus.fetchMore;\n    }\n  }\n\n  public markQueryResult(\n    queryId: string,\n    result: ExecutionResult,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store || !this.store[queryId]) return;\n\n    this.store[queryId].networkError = null;\n    this.store[queryId].graphQLErrors =\n      result.errors && result.errors.length ? result.errors : [];\n    this.store[queryId].previousVariables = null;\n    this.store[queryId].networkStatus = NetworkStatus.ready;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (\n      typeof fetchMoreForQueryId === 'string' &&\n      this.store[fetchMoreForQueryId]\n    ) {\n      this.store[fetchMoreForQueryId].networkStatus = NetworkStatus.ready;\n    }\n  }\n\n  public markQueryError(\n    queryId: string,\n    error: Error,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store || !this.store[queryId]) return;\n\n    this.store[queryId].networkError = error;\n    this.store[queryId].networkStatus = NetworkStatus.error;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (typeof fetchMoreForQueryId === 'string') {\n      this.markQueryResultClient(fetchMoreForQueryId, true);\n    }\n  }\n\n  public markQueryResultClient(queryId: string, complete: boolean) {\n    if (!this.store || !this.store[queryId]) return;\n\n    this.store[queryId].networkError = null;\n    this.store[queryId].previousVariables = null;\n    this.store[queryId].networkStatus = complete\n      ? NetworkStatus.ready\n      : NetworkStatus.loading;\n  }\n\n  public stopQuery(queryId: string) {\n    delete this.store[queryId];\n  }\n\n  public reset(observableQueryIds: string[]) {\n    // keep only the queries with query ids that are associated with observables\n    this.store = Object.keys(this.store)\n      .filter(queryId => {\n        return observableQueryIds.indexOf(queryId) > -1;\n      })\n      .reduce(\n        (res, key) => {\n          // XXX set loading to true so listeners don't trigger unless they want results with partial data\n          res[key] = {\n            ...this.store[key],\n            networkStatus: NetworkStatus.loading,\n          };\n\n          return res;\n        },\n        {} as { [queryId: string]: QueryStoreValue },\n      );\n  }\n}\n","export function capitalizeFirstLetter(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n","import {\n  ExecutionResult,\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  SelectionNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  FieldNode,\n  ASTNode,\n} from 'graphql';\nimport { visit, BREAK } from 'graphql/language/visitor';\n\nimport { ApolloCache } from 'apollo-cache';\nimport {\n  getMainDefinition,\n  buildQueryFromSelectionSet,\n  hasDirectives,\n  removeClientSetsFromDocument,\n  mergeDeep,\n  mergeDeepArray,\n  FragmentMap,\n  argumentsObjectFromField,\n  resultKeyNameFromField,\n  getFragmentDefinitions,\n  createFragmentMap,\n  shouldInclude,\n  isField,\n  isInlineFragment,\n} from 'apollo-utilities';\n\nimport { invariant } from 'ts-invariant';\n\nimport ApolloClient from '../ApolloClient';\nimport { Resolvers, OperationVariables } from './types';\nimport { capitalizeFirstLetter } from '../util/capitalizeFirstLetter';\n\nexport type Resolver = (\n  fieldName: string,\n  rootValue: any,\n  args: any,\n  context: any,\n  info: {\n    field: FieldNode;\n  },\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any,\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  context: any;\n  variables: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n  defaultOperationType: string;\n  exportedVariables: Record<string, any>;\n  onlyRunForcedResolvers: boolean;\n};\n\nexport type LocalStateOptions<TCacheShape> = {\n  cache: ApolloCache<TCacheShape>;\n  client?: ApolloClient<TCacheShape>;\n  resolvers?: Resolvers | Resolvers[];\n  fragmentMatcher?: FragmentMatcher;\n};\n\nexport class LocalState<TCacheShape> {\n  private cache: ApolloCache<TCacheShape>;\n  private client: ApolloClient<TCacheShape>;\n  private resolvers?: Resolvers;\n  private fragmentMatcher: FragmentMatcher;\n\n  constructor({\n    cache,\n    client,\n    resolvers,\n    fragmentMatcher,\n  }: LocalStateOptions<TCacheShape>) {\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach(resolverGroup => {\n        this.resolvers = mergeDeep(this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  }\n\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  }\n\n  public getResolvers() {\n    return this.resolvers || {};\n  }\n\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  public async runResolvers<TData>({\n    document,\n    remoteResult,\n    context,\n    variables,\n    onlyRunForcedResolvers = false,\n  }: {\n    document: DocumentNode | null;\n    remoteResult: ExecutionResult<TData>;\n    context?: Record<string, any>;\n    variables?: Record<string, any>;\n    onlyRunForcedResolvers?: boolean;\n  }): Promise<ExecutionResult<TData>> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        remoteResult.data,\n        context,\n        variables,\n        this.fragmentMatcher,\n        onlyRunForcedResolvers,\n      ).then(localResult => ({\n        ...remoteResult,\n        data: localResult.result,\n      }));\n    }\n\n    return remoteResult;\n  }\n\n  public setFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  }\n\n  public getFragmentMatcher(): FragmentMatcher {\n    return this.fragmentMatcher;\n  }\n\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  public clientQuery(document: DocumentNode) {\n    if (hasDirectives(['client'], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n      invariant.warn(\n        'Found @client directives in query but no client resolvers were specified. ' +\n          'You can now pass apollo-link-state resolvers to the ApolloClient constructor.',\n      );\n    }\n    return null;\n  }\n\n  // Server queries are stripped of all @client based selection sets.\n  public serverQuery(document: DocumentNode) {\n    return this.resolvers ? removeClientSetsFromDocument(document) : document;\n  }\n\n  public prepareContext(context = {}) {\n    const { cache } = this;\n\n    const newContext = {\n      ...context,\n      cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey: (obj: { __typename: string; id: string | number }) => {\n        if ((cache as any).config) {\n          return (cache as any).config.dataIdFromObject(obj);\n        } else {\n          invariant(false,\n            'To use context.getCacheKey, you need to use a cache that has ' +\n              'a configurable dataIdFromObject, like apollo-cache-inmemory.',\n          );\n        }\n      },\n    };\n\n    return newContext;\n  }\n\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  public async addExportedVariables(\n    document: DocumentNode,\n    variables: OperationVariables = {},\n    context = {},\n  ) {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        this.buildRootValueFromCache(document, variables) || {},\n        this.prepareContext(context),\n        variables,\n      ).then(data => ({\n        ...variables,\n        ...data.exportedVariables,\n      }));\n    }\n\n    return {\n      ...variables,\n    };\n  }\n\n  public shouldForceResolvers(document: ASTNode) {\n    let forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter(node) {\n          if (node.name.value === 'client' && node.arguments) {\n            forceResolvers = node.arguments.some(\n              arg =>\n                arg.name.value === 'always' &&\n                arg.value.kind === 'BooleanValue' &&\n                arg.value.value === true,\n            );\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        },\n      },\n    });\n    return forceResolvers;\n  }\n\n  public shouldForceResolver(field: FieldNode) {\n    return this.shouldForceResolvers(field);\n  }\n\n  // Query the cache and return matching data.\n  private buildRootValueFromCache(\n    document: DocumentNode,\n    variables?: Record<string, any>,\n  ) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables,\n      optimistic: false,\n    }).result;\n  }\n\n  private async resolveDocument<TData>(\n    document: DocumentNode,\n    rootValue: TData,\n    context: any = {},\n    variables: VariableMap = {},\n    fragmentMatcher: FragmentMatcher = () => true,\n    onlyRunForcedResolvers: boolean = false,\n  ) {\n    const mainDefinition = getMainDefinition(document);\n    const fragments = getFragmentDefinitions(document);\n    const fragmentMap = createFragmentMap(fragments);\n\n    const definitionOperation = (mainDefinition as OperationDefinitionNode)\n      .operation;\n\n    const defaultOperationType = definitionOperation\n      ? capitalizeFirstLetter(definitionOperation)\n      : 'Query';\n\n    const { cache, client } = this;\n    const execContext: ExecContext = {\n      fragmentMap,\n      context: {\n        ...context,\n        cache,\n        client,\n      },\n      variables,\n      fragmentMatcher,\n      defaultOperationType,\n      exportedVariables: {},\n      onlyRunForcedResolvers,\n    };\n\n    return this.resolveSelectionSet(\n      mainDefinition.selectionSet,\n      rootValue,\n      execContext,\n    ).then(result => ({\n      result,\n      exportedVariables: execContext.exportedVariables,\n    }));\n  }\n\n  private async resolveSelectionSet<TData>(\n    selectionSet: SelectionSetNode,\n    rootValue: TData,\n    execContext: ExecContext,\n  ) {\n    const { fragmentMap, context, variables } = execContext;\n    const resultsToMerge: TData[] = [rootValue];\n\n    const execute = async (selection: SelectionNode): Promise<void> => {\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely.\n        return;\n      }\n\n      if (isField(selection)) {\n        return this.resolveField(selection, rootValue, execContext).then(\n          fieldResult => {\n            if (typeof fieldResult !== 'undefined') {\n              resultsToMerge.push({\n                [resultKeyNameFromField(selection)]: fieldResult,\n              } as TData);\n            }\n          },\n        );\n      }\n\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment.\n        fragment = fragmentMap[selection.name.value];\n        invariant(fragment, `No fragment named ${selection.name.value}`);\n      }\n\n      if (fragment && fragment.typeCondition) {\n        const typeCondition = fragment.typeCondition.name.value;\n        if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n          return this.resolveSelectionSet(\n            fragment.selectionSet,\n            rootValue,\n            execContext,\n          ).then(fragmentResult => {\n            resultsToMerge.push(fragmentResult);\n          });\n        }\n      }\n    };\n\n    return Promise.all(selectionSet.selections.map(execute)).then(function() {\n      return mergeDeepArray(resultsToMerge);\n    });\n  }\n\n  private async resolveField(\n    field: FieldNode,\n    rootValue: any,\n    execContext: ExecContext,\n  ): Promise<any> {\n    const { variables } = execContext;\n    const fieldName = field.name.value;\n    const aliasedFieldName = resultKeyNameFromField(field);\n    const aliasUsed = fieldName !== aliasedFieldName;\n    const defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n    let resultPromise = Promise.resolve(defaultResult);\n\n    // Usually all local resolvers are run when passing through here, but\n    // if we've specifically identified that we only want to run forced\n    // resolvers (that is, resolvers for fields marked with\n    // `@client(always: true)`), then we'll skip running non-forced resolvers.\n    if (\n      !execContext.onlyRunForcedResolvers ||\n      this.shouldForceResolver(field)\n    ) {\n      const resolverType =\n        rootValue.__typename || execContext.defaultOperationType;\n      const resolverMap = this.resolvers && this.resolvers[resolverType];\n      if (resolverMap) {\n        const resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n        if (resolve) {\n          resultPromise = Promise.resolve(resolve(\n            rootValue,\n            argumentsObjectFromField(field, variables),\n            execContext.context,\n            { field },\n          ));\n        }\n      }\n    }\n\n    return resultPromise.then((result = defaultResult) => {\n      // If an @export directive is associated with the current field, store\n      // the `as` export variable name and current result for later use.\n      if (field.directives) {\n        field.directives.forEach(directive => {\n          if (directive.name.value === 'export' && directive.arguments) {\n            directive.arguments.forEach(arg => {\n              if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {\n                execContext.exportedVariables[arg.value.value] = result;\n              }\n            });\n          }\n        });\n      }\n\n      // Handle all scalar types here.\n      if (!field.selectionSet) {\n        return result;\n      }\n\n      // From here down, the field has a selection set, which means it's trying\n      // to query a GraphQLObjectType.\n      if (result == null) {\n        // Basically any field in a GraphQL response can be null, or missing\n        return result;\n      }\n\n      if (Array.isArray(result)) {\n        return this.resolveSubSelectedArray(field, result, execContext);\n      }\n\n      // Returned value is an object, and the query has a sub-selection. Recurse.\n      if (field.selectionSet) {\n        return this.resolveSelectionSet(\n          field.selectionSet,\n          result,\n          execContext,\n        );\n      }\n    });\n  }\n\n  private resolveSubSelectedArray(\n    field: FieldNode,\n    result: any[],\n    execContext: ExecContext,\n  ): any {\n    return Promise.all(\n      result.map(item => {\n        if (item === null) {\n          return null;\n        }\n\n        // This is a nested array, recurse.\n        if (Array.isArray(item)) {\n          return this.resolveSubSelectedArray(field, item, execContext);\n        }\n\n        // This is an object, run the selection set on it.\n        if (field.selectionSet) {\n          return this.resolveSelectionSet(field.selectionSet, item, execContext);\n        }\n      }),\n    );\n  }\n}\n","import { execute, ApolloLink, FetchResult } from 'apollo-link';\nimport { ExecutionResult, DocumentNode } from 'graphql';\nimport { DedupLink as Deduplicator } from 'apollo-link-dedup';\nimport { Cache } from 'apollo-cache';\nimport {\n  assign,\n  getDefaultValues,\n  getMutationDefinition,\n  getOperationDefinition,\n  getOperationName,\n  getQueryDefinition,\n  hasDirectives,\n  graphQLResultHasError,\n  hasClientExports,\n} from 'apollo-utilities';\n\nimport { invariant } from 'ts-invariant';\n\nimport { isApolloError, ApolloError } from '../errors/ApolloError';\nimport { Observer, Subscription, Observable } from '../util/Observable';\nimport { QueryWithUpdater, DataStore } from '../data/store';\nimport { MutationStore } from '../data/mutations';\nimport { QueryStore, QueryStoreValue } from '../data/queries';\n\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n} from './watchQueryOptions';\nimport { ObservableQuery } from './ObservableQuery';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport {\n  QueryListener,\n  ApolloQueryResult,\n  FetchType,\n  OperationVariables,\n} from './types';\nimport { LocalState } from './LocalState';\n\nexport interface QueryInfo {\n  listeners: QueryListener[];\n  invalidated: boolean;\n  newData: Cache.DiffResult<any> | null;\n  document: DocumentNode | null;\n  lastRequestId: number | null;\n  // A map going from queryId to an observer for a query issued by watchQuery. We use\n  // these to keep track of queries that are inflight and error on the observers associated\n  // with them in case of some destabalizing action (e.g. reset of the Apollo store).\n  observableQuery: ObservableQuery<any> | null;\n  subscriptions: Subscription[];\n  cancel?: () => void;\n}\n\nexport class QueryManager<TStore> {\n  public link: ApolloLink;\n  public mutationStore: MutationStore = new MutationStore();\n  public queryStore: QueryStore = new QueryStore();\n  public dataStore: DataStore<TStore>;\n\n  private deduplicator: ApolloLink;\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast: () => void;\n\n  private ssrMode: boolean;\n\n  // let's not start at zero to avoid pain with bad checks\n  private idCounter = 1;\n\n  // XXX merge with ObservableQuery but that needs to be expanded to support mutations and\n  // subscriptions as well\n  private queries: Map<string, QueryInfo> = new Map();\n\n  // A map of Promise reject functions for fetchQuery promises that have not\n  // yet been resolved, used to keep track of in-flight queries so that we can\n  // reject them in case a destabilizing event occurs (e.g. Apollo store reset).\n  // The key is in the format of `query:${queryId}` or `fetchRequest:${queryId}`,\n  // depending on where the promise's rejection function was created from.\n  private fetchQueryRejectFns = new Map<string, Function>();\n\n  // A map going from the name of a query to an observer issued for it by watchQuery. This is\n  // generally used to refetches for refetchQueries and to update mutation results through\n  // updateQueries.\n  private queryIdsByName: { [queryName: string]: string[] } = {};\n\n  constructor({\n    link,\n    queryDeduplication = false,\n    store,\n    onBroadcast = () => undefined,\n    ssrMode = false,\n    clientAwareness = {},\n    localState,\n  }: {\n    link: ApolloLink;\n    queryDeduplication?: boolean;\n    store: DataStore<TStore>;\n    onBroadcast?: () => void;\n    ssrMode?: boolean;\n    clientAwareness?: Record<string, string>;\n    localState?: LocalState<TStore>;\n  }) {\n    this.link = link;\n    this.deduplicator = ApolloLink.from([new Deduplicator(), link]);\n    this.queryDeduplication = queryDeduplication;\n    this.dataStore = store;\n    this.onBroadcast = onBroadcast;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({ cache: store.getCache() });\n    this.ssrMode = ssrMode;\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.fetchQueryRejectFns.forEach(reject => {\n      reject(new Error('QueryManager stopped while query was in flight'));\n    });\n  }\n\n  public async mutate<T>({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries: updateQueriesByName,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    errorPolicy = 'none',\n    fetchPolicy,\n    context = {},\n  }: MutationOptions): Promise<FetchResult<T>> {\n    invariant(\n      mutation,\n      'mutation option is required. You must specify your GraphQL document in the mutation option.',\n    );\n\n    invariant(\n      !fetchPolicy || fetchPolicy === 'no-cache',\n      \"fetchPolicy for mutations currently only supports the 'no-cache' policy\"\n    );\n\n    const mutationId = this.generateQueryId();\n    const cache = this.dataStore.getCache();\n    (mutation = cache.transformDocument(mutation)),\n      (variables = assign(\n        {},\n        getDefaultValues(getMutationDefinition(mutation)),\n        variables,\n      ));\n\n    this.setQuery(mutationId, () => ({ document: mutation }));\n\n    // Create a map of update queries by id to the query instead of by name.\n    const generateUpdateQueriesInfo: () => {\n      [queryId: string]: QueryWithUpdater;\n    } = () => {\n      const ret: { [queryId: string]: QueryWithUpdater } = {};\n\n      if (updateQueriesByName) {\n        Object.keys(updateQueriesByName).forEach(queryName =>\n          (this.queryIdsByName[queryName] || []).forEach(queryId => {\n            ret[queryId] = {\n              updater: updateQueriesByName[queryName],\n              query: this.queryStore.get(queryId),\n            };\n          }),\n        );\n      }\n\n      return ret;\n    };\n\n    const updatedVariables: OperationVariables =\n      hasClientExports(mutation)\n        ? await this.localState.addExportedVariables(\n            mutation,\n            variables,\n            context,\n          )\n        : variables;\n\n    this.mutationStore.initMutation(\n      mutationId,\n      mutation,\n      updatedVariables,\n    );\n\n    this.dataStore.markMutationInit({\n      mutationId,\n      document: mutation,\n      variables: updatedVariables || {},\n      updateQueries: generateUpdateQueriesInfo(),\n      update: updateWithProxyFn,\n      optimisticResponse,\n    });\n\n    this.broadcastQueries();\n\n    return new Promise((resolve, reject) => {\n      let storeResult: FetchResult<T> | null;\n      let error: ApolloError;\n\n      const operation = this.buildOperationForLink(mutation, updatedVariables, {\n        ...context,\n        optimisticResponse,\n      });\n\n      const completeMutation = () => {\n        if (error) {\n          this.mutationStore.markMutationError(mutationId, error);\n        }\n\n        this.dataStore.markMutationComplete({\n          mutationId,\n          optimisticResponse,\n        });\n\n        this.broadcastQueries();\n\n        if (error) {\n          return Promise.reject(error);\n        }\n\n        // allow for conditional refetches\n        // XXX do we want to make this the only API one day?\n        if (typeof refetchQueries === 'function') {\n          refetchQueries = refetchQueries(storeResult as ExecutionResult);\n        }\n\n        const refetchQueryPromises: Promise<\n          ApolloQueryResult<any>[] | ApolloQueryResult<{}>\n        >[] = [];\n\n        for (const refetchQuery of refetchQueries) {\n          if (typeof refetchQuery === 'string') {\n            const promise = this.refetchQueryByName(refetchQuery);\n            if (promise) {\n              refetchQueryPromises.push(promise);\n            }\n            continue;\n          }\n\n          const queryOptions: QueryOptions = {\n            query: refetchQuery.query,\n            variables: refetchQuery.variables,\n            fetchPolicy: 'network-only',\n          };\n\n          if (refetchQuery.context) {\n            queryOptions.context = refetchQuery.context;\n          }\n\n          refetchQueryPromises.push(this.query(queryOptions));\n        }\n\n        return Promise.all(\n          awaitRefetchQueries ? refetchQueryPromises : [],\n        ).then(() => {\n          this.setQuery(mutationId, () => ({ document: null }));\n\n          if (\n            errorPolicy === 'ignore' &&\n            storeResult &&\n            graphQLResultHasError(storeResult)\n          ) {\n            delete storeResult.errors;\n          }\n\n          return storeResult as FetchResult<T>;\n        });\n      };\n\n      const clientQuery = this.localState.clientQuery(operation.query);\n      const serverQuery = this.localState.serverQuery(operation.query);\n      if (serverQuery) {\n        operation.query = serverQuery;\n      }\n\n      const obs: Observable<FetchResult> = serverQuery\n        ? execute(this.link, operation)\n        : Observable.of({\n            data: {},\n          });\n\n      const self = this;\n      let complete = false;\n      let handlingNext = false;\n      obs.subscribe({\n        next: async (result: ExecutionResult) => {\n          handlingNext = true;\n\n          if (graphQLResultHasError(result) && errorPolicy === 'none') {\n            handlingNext = false;\n            error = new ApolloError({\n              graphQLErrors: result.errors,\n            });\n            return;\n          }\n\n          self.mutationStore.markMutationResult(mutationId);\n          let updatedResult = result;\n          const { context, variables } = operation;\n\n          // Run the query through local client resolvers.\n          if (clientQuery && hasDirectives(['client'], clientQuery)) {\n            updatedResult = await self.localState\n              .runResolvers({\n                document: clientQuery,\n                remoteResult: result,\n                context,\n                variables,\n              })\n              .catch(error => {\n                handlingNext = false;\n                reject(error);\n                return result;\n              });\n          }\n\n          if (fetchPolicy !== 'no-cache') {\n            self.dataStore.markMutationResult({\n              mutationId,\n              result: updatedResult,\n              document: mutation,\n              variables: updatedVariables || {},\n              updateQueries: generateUpdateQueriesInfo(),\n              update: updateWithProxyFn,\n            });\n          }\n\n          storeResult = updatedResult as FetchResult<T>;\n\n          handlingNext = false;\n          if (complete) {\n            completeMutation().then(resolve, reject);\n          }\n        },\n\n        error(err: Error) {\n          self.mutationStore.markMutationError(mutationId, err);\n          self.dataStore.markMutationComplete({\n            mutationId,\n            optimisticResponse,\n          });\n          self.broadcastQueries();\n\n          self.setQuery(mutationId, () => ({ document: null }));\n          reject(\n            new ApolloError({\n              networkError: err,\n            }),\n          );\n        },\n\n        complete() {\n          if (!handlingNext) {\n            completeMutation().then(resolve, reject);\n          }\n          complete = true;\n        },\n      });\n    });\n  }\n\n  public async fetchQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    fetchType?: FetchType,\n    // This allows us to track if this is a query spawned by a `fetchMore`\n    // call for another query. We need this data to compute the `fetchMore`\n    // network status for the query this is fetching for.\n    fetchMoreForQueryId?: string,\n  ): Promise<FetchResult<T>> {\n    const {\n      variables = {},\n      metadata = null,\n      fetchPolicy = 'cache-first', // cache-first is the default fetch policy.\n      context = {},\n    } = options;\n    const cache = this.dataStore.getCache();\n    const query = cache.transformDocument(options.query);\n\n    const updatedVariables: OperationVariables =\n      hasClientExports(query)\n        ? await this.localState.addExportedVariables(query, variables, context)\n        : variables;\n\n    const updatedOptions: WatchQueryOptions = {\n      ...options,\n      ...{ variables: updatedVariables },\n    };\n\n    let storeResult: any;\n    let needToFetch: boolean =\n      fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';\n\n    // If this is not a force fetch, we want to diff the query against the\n    // store before we fetch it from the network interface.\n    // TODO we hit the cache even if the policy is network-first. This could be unnecessary if the network is up.\n    if (\n      fetchType !== FetchType.refetch &&\n      fetchPolicy !== 'network-only' &&\n      fetchPolicy !== 'no-cache'\n    ) {\n      const { complete, result } = this.dataStore.getCache().diff({\n        query,\n        variables: updatedVariables,\n        returnPartialData: true,\n        optimistic: false,\n      });\n\n      // If we're in here, only fetch if we have missing fields\n      needToFetch = !complete || fetchPolicy === 'cache-and-network';\n      storeResult = result;\n    }\n\n    let shouldFetch =\n      needToFetch && fetchPolicy !== 'cache-only' && fetchPolicy !== 'standby';\n\n    // we need to check to see if this is an operation that uses the @live directive\n    if (hasDirectives(['live'], query)) shouldFetch = true;\n\n    const requestId = this.generateRequestId();\n\n    // set up a watcher to listen to cache updates\n    const cancel = this.updateQueryWatch(queryId, query, updatedOptions);\n\n    // Initialize query in store with unique requestId\n    this.setQuery(queryId, () => ({\n      document: query,\n      lastRequestId: requestId,\n      invalidated: true,\n      cancel,\n    }));\n\n    this.invalidate(true, fetchMoreForQueryId);\n\n    this.queryStore.initQuery({\n      queryId,\n      document: query,\n      storePreviousVariables: shouldFetch,\n      variables: updatedVariables,\n      isPoll: fetchType === FetchType.poll,\n      isRefetch: fetchType === FetchType.refetch,\n      metadata,\n      fetchMoreForQueryId,\n    });\n\n    this.broadcastQueries();\n\n    // If there is no part of the query we need to fetch from the server (or,\n    // fetchPolicy is cache-only), we just write the store result as the final result.\n    const shouldDispatchClientResult =\n      !shouldFetch || fetchPolicy === 'cache-and-network';\n    if (shouldDispatchClientResult) {\n      this.queryStore.markQueryResultClient(queryId, !shouldFetch);\n      this.invalidate(true, queryId, fetchMoreForQueryId);\n      this.broadcastQueries(this.localState.shouldForceResolvers(query));\n    }\n\n    if (shouldFetch) {\n      const networkResult = this.fetchRequest<T>({\n        requestId,\n        queryId,\n        document: query,\n        options: updatedOptions,\n        fetchMoreForQueryId,\n      }).catch(error => {\n        // This is for the benefit of `refetch` promises, which currently don't get their errors\n        // through the store like watchQuery observers do\n        if (isApolloError(error)) {\n          throw error;\n        } else {\n          const { lastRequestId } = this.getQuery(queryId);\n          if (requestId >= (lastRequestId || 1)) {\n            this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);\n\n            this.invalidate(true, queryId, fetchMoreForQueryId);\n\n            this.broadcastQueries();\n          }\n\n          throw new ApolloError({ networkError: error });\n        }\n      });\n\n      // we don't return the promise for cache-and-network since it is already\n      // returned below from the cache\n      if (fetchPolicy !== 'cache-and-network') {\n        return networkResult;\n      } else {\n        // however we need to catch the error so it isn't unhandled in case of\n        // network error\n        networkResult.catch(() => {});\n      }\n    }\n\n    // If we have no query to send to the server, we should return the result\n    // found within the store.\n    return Promise.resolve({ data: storeResult });\n  }\n\n  // Returns a query listener that will update the given observer based on the\n  // results (or lack thereof) for a particular query.\n  public queryListenerForObserver<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    observer: Observer<ApolloQueryResult<T>>,\n  ): QueryListener {\n    let previouslyHadError: boolean = false;\n    return async (\n      queryStoreValue: QueryStoreValue,\n      newData?: Cache.DiffResult<T>,\n      forceResolvers?: boolean,\n    ) => {\n      // we're going to take a look at the data, so the query is no longer invalidated\n      this.invalidate(false, queryId);\n\n      // The query store value can be undefined in the event of a store\n      // reset.\n      if (!queryStoreValue) return;\n\n      const { observableQuery } = this.getQuery(queryId);\n\n      const fetchPolicy = observableQuery\n        ? observableQuery.options.fetchPolicy\n        : options.fetchPolicy;\n\n      // don't watch the store for queries on standby\n      if (fetchPolicy === 'standby') return;\n\n      const errorPolicy = observableQuery\n        ? observableQuery.options.errorPolicy\n        : options.errorPolicy;\n\n      const lastResult = observableQuery\n        ? observableQuery.getLastResult()\n        : null;\n\n      const lastError = observableQuery ? observableQuery.getLastError() : null;\n\n      let shouldNotifyIfLoading =\n        (!newData && queryStoreValue.previousVariables != null) ||\n        fetchPolicy === 'cache-only' ||\n        fetchPolicy === 'cache-and-network';\n\n      // if this caused by a cache broadcast but the query is still in flight\n      // don't notify the observer\n      // if (\n      //   isCacheBroadcast &&\n      //   isNetworkRequestInFlight(queryStoreValue.networkStatus)\n      // ) {\n      //   shouldNotifyIfLoading = false;\n      // }\n\n      const networkStatusChanged = Boolean(\n        lastResult &&\n          queryStoreValue.networkStatus !== lastResult.networkStatus,\n      );\n\n      const errorStatusChanged =\n        errorPolicy &&\n        (lastError && lastError.graphQLErrors) !==\n          queryStoreValue.graphQLErrors &&\n        errorPolicy !== 'none';\n\n      if (\n        !isNetworkRequestInFlight(queryStoreValue.networkStatus) ||\n        (networkStatusChanged && options.notifyOnNetworkStatusChange) ||\n        shouldNotifyIfLoading\n      ) {\n        // If we have either a GraphQL error or a network error, we create\n        // an error and tell the observer about it.\n        if (\n          ((!errorPolicy || errorPolicy === 'none') &&\n            queryStoreValue.graphQLErrors &&\n            queryStoreValue.graphQLErrors.length > 0) ||\n          queryStoreValue.networkError\n        ) {\n          const apolloError = new ApolloError({\n            graphQLErrors: queryStoreValue.graphQLErrors,\n            networkError: queryStoreValue.networkError,\n          });\n          previouslyHadError = true;\n          if (observer.error) {\n            try {\n              observer.error(apolloError);\n            } catch (e) {\n              // Throw error outside this control flow to avoid breaking Apollo's state\n              setTimeout(() => {\n                throw e;\n              }, 0);\n            }\n          } else {\n            // Throw error outside this control flow to avoid breaking Apollo's state\n            setTimeout(() => {\n              throw apolloError;\n            }, 0);\n            if (process.env.NODE_ENV !== 'production') {\n              /* tslint:disable-next-line */\n              console.info(\n                'An unhandled error was thrown because no error handler is registered ' +\n                  'for the query ' +\n                  JSON.stringify(queryStoreValue.document),\n              );\n            }\n          }\n          return;\n        }\n\n        try {\n          let data: any;\n          let isMissing: boolean;\n\n          if (newData) {\n            // As long as we're using the cache, clear out the latest\n            // `newData`, since it will now become the current data. We need\n            // to keep the `newData` stored with the query when using\n            // `no-cache` since `getCurrentQueryResult` attemps to pull from\n            // `newData` first, following by trying the cache (which won't\n            // find a hit for `no-cache`).\n            if (fetchPolicy !== 'no-cache' && fetchPolicy !== 'network-only') {\n              this.setQuery(queryId, () => ({ newData: null }));\n            }\n\n            data = newData.result;\n            isMissing = !newData.complete || false;\n          } else {\n            if (lastResult && lastResult.data && !errorStatusChanged) {\n              data = lastResult.data;\n              isMissing = false;\n            } else {\n              const { document } = this.getQuery(queryId);\n              const readResult = this.dataStore.getCache().diff({\n                query: document as DocumentNode,\n                variables:\n                  queryStoreValue.previousVariables ||\n                  queryStoreValue.variables,\n                optimistic: true,\n              });\n\n              data = readResult.result;\n              isMissing = !readResult.complete;\n            }\n          }\n\n          let resultFromStore: ApolloQueryResult<T>;\n\n          // If there is some data missing and the user has told us that they\n          // do not tolerate partial data then we want to return the previous\n          // result and mark it as stale.\n          if (isMissing && fetchPolicy !== 'cache-only') {\n            resultFromStore = {\n              data: lastResult && lastResult.data,\n              loading: isNetworkRequestInFlight(queryStoreValue.networkStatus),\n              networkStatus: queryStoreValue.networkStatus,\n              stale: true,\n            };\n          } else {\n            resultFromStore = {\n              data,\n              loading: isNetworkRequestInFlight(queryStoreValue.networkStatus),\n              networkStatus: queryStoreValue.networkStatus,\n              stale: false,\n            };\n          }\n\n          // if the query wants updates on errors we need to add it to the result\n          if (\n            errorPolicy === 'all' &&\n            queryStoreValue.graphQLErrors &&\n            queryStoreValue.graphQLErrors.length > 0\n          ) {\n            resultFromStore.errors = queryStoreValue.graphQLErrors;\n          }\n\n          if (observer.next) {\n            if (\n              previouslyHadError ||\n              !observableQuery ||\n              observableQuery.isDifferentFromLastResult(resultFromStore)\n            ) {\n              try {\n                // Local resolvers can be forced by using\n                // `@client(always: true)` syntax. If any resolvers are\n                // forced, we'll make sure they're run here to override any\n                // data returned from the cache. Only the selection sets and\n                // fields marked with `@client(always: true)` are overwritten.\n                if (forceResolvers) {\n                  const { query, variables, context } = options;\n\n                  const updatedResult = await this.localState.runResolvers({\n                    document: query,\n                    remoteResult: resultFromStore,\n                    context,\n                    variables,\n                    onlyRunForcedResolvers: forceResolvers,\n                  });\n\n                  resultFromStore = {\n                    ...resultFromStore,\n                    ...updatedResult,\n                  };\n                }\n\n                observer.next(resultFromStore);\n              } catch (e) {\n                // Throw error outside this control flow to avoid breaking Apollo's state\n                setTimeout(() => {\n                  throw e;\n                }, 0);\n              }\n            }\n          }\n          previouslyHadError = false;\n        } catch (error) {\n          previouslyHadError = true;\n          if (observer.error)\n            observer.error(new ApolloError({ networkError: error }));\n          return;\n        }\n      }\n    };\n  }\n\n  // The shouldSubscribe option is a temporary fix that tells us whether watchQuery was called\n  // directly (i.e. through ApolloClient) or through the query method within QueryManager.\n  // Currently, the query method uses watchQuery in order to handle non-network errors correctly\n  // but we don't want to keep track observables issued for the query method since those aren't\n  // supposed to be refetched in the event of a store reset. Once we unify error handling for\n  // network errors and non-network errors, the shouldSubscribe option will go away.\n\n  public watchQuery<T, TVariables = OperationVariables>(\n    options: WatchQueryOptions,\n    shouldSubscribe = true,\n  ): ObservableQuery<T, TVariables> {\n    invariant(\n      options.fetchPolicy !== 'standby',\n      'client.watchQuery cannot be called with fetchPolicy set to \"standby\"',\n    );\n\n    // get errors synchronously\n    const queryDefinition = getQueryDefinition(options.query);\n\n    // assign variable default values if supplied\n    if (\n      queryDefinition.variableDefinitions &&\n      queryDefinition.variableDefinitions.length\n    ) {\n      const defaultValues = getDefaultValues(queryDefinition);\n\n      options.variables = assign({}, defaultValues, options.variables);\n    }\n\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    let transformedOptions = { ...options } as WatchQueryOptions<TVariables>;\n\n    return new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      options: transformedOptions,\n      shouldSubscribe: shouldSubscribe,\n    });\n  }\n\n  public query<T>(options: QueryOptions): Promise<ApolloQueryResult<T>> {\n    invariant(\n      options.query,\n      'query option is required. You must specify your GraphQL document ' +\n        'in the query option.',\n    );\n\n    invariant(\n      options.query.kind === 'Document',\n      'You must wrap the query string in a \"gql\" tag.',\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      'returnPartialData option only supported on watchQuery.',\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      'pollInterval option only supported on watchQuery.',\n    );\n\n    return new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      const watchedQuery = this.watchQuery<T>(options, false);\n      this.fetchQueryRejectFns.set(`query:${watchedQuery.queryId}`, reject);\n      watchedQuery\n        .result()\n        .then(resolve, reject)\n        // Since neither resolve nor reject throw or return a value, this .then\n        // handler is guaranteed to execute. Note that it doesn't really matter\n        // when we remove the reject function from this.fetchQueryRejectFns,\n        // since resolve and reject are mutually idempotent. In fact, it would\n        // not be incorrect to let reject functions accumulate over time; it's\n        // just a waste of memory.\n        .then(() =>\n          this.fetchQueryRejectFns.delete(`query:${watchedQuery.queryId}`),\n        );\n    });\n  }\n\n  public generateQueryId() {\n    const queryId = this.idCounter.toString();\n    this.idCounter++;\n    return queryId;\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    this.stopPollingQuery(queryId);\n    this.queryStore.stopQuery(queryId);\n    this.invalidate(true, queryId);\n  }\n\n  public addQueryListener(queryId: string, listener: QueryListener) {\n    this.setQuery(queryId, ({ listeners = [] }) => ({\n      listeners: listeners.concat([listener]),\n      invalidated: false,\n    }));\n  }\n\n  public updateQueryWatch(\n    queryId: string,\n    document: DocumentNode,\n    options: WatchQueryOptions,\n  ) {\n    const { cancel } = this.getQuery(queryId);\n    if (cancel) cancel();\n    const previousResult = () => {\n      let previousResult = null;\n      const { observableQuery } = this.getQuery(queryId);\n      if (observableQuery) {\n        const lastResult = observableQuery.getLastResult();\n        if (lastResult) {\n          previousResult = lastResult.data;\n        }\n      }\n\n      return previousResult;\n    };\n    return this.dataStore.getCache().watch({\n      query: document as DocumentNode,\n      variables: options.variables,\n      optimistic: true,\n      previousResult,\n      callback: newData => {\n        this.setQuery(queryId, () => ({ invalidated: true, newData }));\n      },\n    });\n  }\n\n  // Adds an ObservableQuery to this.observableQueries and to this.observableQueriesByName.\n  public addObservableQuery<T>(\n    queryId: string,\n    observableQuery: ObservableQuery<T>,\n  ) {\n    this.setQuery(queryId, () => ({ observableQuery }));\n\n    // Insert the ObservableQuery into this.observableQueriesByName if the query has a name\n    const queryDef = getQueryDefinition(observableQuery.options.query);\n    if (queryDef.name && queryDef.name.value) {\n      const queryName = queryDef.name.value;\n\n      // XXX we may we want to warn the user about query name conflicts in the future\n      this.queryIdsByName[queryName] = this.queryIdsByName[queryName] || [];\n      this.queryIdsByName[queryName].push(observableQuery.queryId);\n    }\n  }\n\n  public removeObservableQuery(queryId: string) {\n    const { observableQuery, cancel } = this.getQuery(queryId);\n    if (cancel) cancel();\n    if (!observableQuery) return;\n\n    const definition = getQueryDefinition(observableQuery.options.query);\n    const queryName = definition.name ? definition.name.value : null;\n    this.setQuery(queryId, () => ({ observableQuery: null }));\n    if (queryName) {\n      this.queryIdsByName[queryName] = this.queryIdsByName[queryName].filter(\n        val => {\n          return !(observableQuery.queryId === val);\n        },\n      );\n    }\n  }\n\n  public clearStore(): Promise<void> {\n    // Before we have sent the reset action to the store,\n    // we can no longer rely on the results returned by in-flight\n    // requests since these may depend on values that previously existed\n    // in the data portion of the store. So, we cancel the promises and observers\n    // that we have issued so far and not yet resolved (in the case of\n    // queries).\n    this.fetchQueryRejectFns.forEach(reject => {\n      reject(\n        new Error(\n          'Store reset while query was in flight(not completed in link chain)',\n        ),\n      );\n    });\n\n    const resetIds: string[] = [];\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (observableQuery) resetIds.push(queryId);\n    });\n\n    this.queryStore.reset(resetIds);\n    this.mutationStore.reset();\n\n    // begin removing data from the store\n    const reset = this.dataStore.reset();\n\n    return reset;\n  }\n\n  public resetStore(): Promise<ApolloQueryResult<any>[]> {\n    // Similarly, we have to have to refetch each of the queries currently being\n    // observed. We refetch instead of error'ing on these since the assumption is that\n    // resetting the store doesn't eliminate the need for the queries currently being\n    // watched. If there is an existing query in flight when the store is reset,\n    // the promise for it will be rejected and its results will not be written to the\n    // store.\n    return this.clearStore().then(() => {\n      return this.reFetchObservableQueries();\n    });\n  }\n\n  public reFetchObservableQueries(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<\n      ApolloQueryResult<any>\n    >[] = this.getObservableQueryPromises(includeStandby);\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public startQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    listener: QueryListener,\n  ) {\n    this.addQueryListener(queryId, listener);\n\n    this.fetchQuery<T>(queryId, options)\n      // `fetchQuery` returns a Promise. In case of a failure it should be caucht or else the\n      // console will show an `Uncaught (in promise)` message. Ignore the error for now.\n      .catch(() => undefined);\n\n    return queryId;\n  }\n\n  public startGraphQLSubscription<T = any>(\n    options: SubscriptionOptions,\n  ): Observable<T> {\n    const { query } = options;\n    const isCacheEnabled = !(\n      options.fetchPolicy && options.fetchPolicy === 'no-cache'\n    );\n    const cache = this.dataStore.getCache();\n    let transformedDoc = cache.transformDocument(query);\n\n    const variables = assign(\n      {},\n      getDefaultValues(getOperationDefinition(query)),\n      options.variables,\n    );\n\n    let updatedVariables = variables;\n    let sub: Subscription;\n    let observers: Observer<any>[] = [];\n    const clientQuery = this.localState.clientQuery(transformedDoc);\n\n    return new Observable(observer => {\n      observers.push(observer);\n\n      // If this is the first observer, actually initiate the network\n      // subscription.\n      if (observers.length === 1) {\n        let activeNextCalls = 0;\n        let complete = false;\n\n        const handler = {\n          next: async (result: FetchResult) => {\n            activeNextCalls += 1;\n            let updatedResult = result;\n\n            // Run the query through local client resolvers.\n            if (clientQuery && hasDirectives(['client'], clientQuery)) {\n              updatedResult = await this.localState.runResolvers({\n                document: clientQuery,\n                remoteResult: result,\n                context: {},\n                variables: updatedVariables,\n              });\n            }\n\n            if (isCacheEnabled) {\n              this.dataStore.markSubscriptionResult(\n                updatedResult,\n                transformedDoc,\n                updatedVariables,\n              );\n              this.broadcastQueries();\n            }\n\n            observers.forEach(obs => {\n              // If an error exists and a `error` handler has been defined on\n              // the observer, call that `error` handler and make sure the\n              // `next` handler is skipped. If no `error` handler exists, we're\n              // still passing any errors that might occur into the `next`\n              // handler, to give that handler a chance to deal with the\n              // error (we're doing this for backwards compatibilty).\n              if (graphQLResultHasError(updatedResult) && obs.error) {\n                obs.error(\n                  new ApolloError({\n                    graphQLErrors: updatedResult.errors,\n                  }),\n                );\n              } else if (obs.next) {\n                obs.next(updatedResult);\n              }\n              activeNextCalls -= 1;\n            });\n\n            if (activeNextCalls === 0 && complete) {\n              handler.complete();\n            }\n          },\n          error: (error: Error) => {\n            observers.forEach(obs => {\n              if (obs.error) {\n                obs.error(error);\n              }\n            });\n          },\n          complete: () => {\n            if (activeNextCalls === 0) {\n              observers.forEach(obs => {\n                if (obs.complete) {\n                  obs.complete();\n                }\n              });\n            }\n            complete = true;\n          }\n        };\n\n        (async () => {\n          const updatedVariables: OperationVariables =\n            hasClientExports(transformedDoc)\n              ? await this.localState.addExportedVariables(\n                  transformedDoc,\n                  variables\n                )\n              : variables;\n          const serverQuery = this.localState.serverQuery(transformedDoc);\n          if (serverQuery) {\n            const operation = this.buildOperationForLink(\n              serverQuery,\n              updatedVariables,\n            );\n            sub = execute(this.link, operation).subscribe(handler);\n          } else {\n            sub = Observable.of({ data: {} }).subscribe(handler);\n          }\n        })();\n      }\n\n      return () => {\n        observers = observers.filter(obs => obs !== observer);\n\n        // If we removed the last observer, tear down the network subscription\n        if (observers.length === 0 && sub) {\n          sub.unsubscribe();\n        }\n      };\n    });\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    const { subscriptions } = this.getQuery(queryId);\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchQueryRejectFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchQueryRejectFns.delete(`query:${queryId}`);\n    this.fetchQueryRejectFns.delete(`fetchRequest:${queryId}`);\n    subscriptions.forEach(x => x.unsubscribe());\n    this.queries.delete(queryId);\n  }\n\n  public getCurrentQueryResult<T>(\n    observableQuery: ObservableQuery<T>,\n    optimistic: boolean = true,\n  ): {\n    data: T | undefined;\n    partial: boolean;\n  } {\n    const { variables, query, fetchPolicy } = observableQuery.options;\n    const lastResult = observableQuery.getLastResult();\n    const { newData } = this.getQuery(observableQuery.queryId);\n\n    // XXX test this\n    if (newData && newData.complete) {\n      return { data: newData.result, partial: false };\n    } else if (fetchPolicy === 'no-cache' || fetchPolicy === 'network-only') {\n      return { data: undefined, partial: false };\n    } else {\n      try {\n        // the query is brand new, so we read from the store to see if anything is there\n        const data =\n          this.dataStore.getCache().read<T>({\n            query,\n            variables,\n            previousResult: lastResult ? lastResult.data : undefined,\n            optimistic,\n          }) || undefined;\n\n        return { data, partial: false };\n      } catch (e) {\n        return { data: undefined, partial: true };\n      }\n    }\n  }\n\n  public getQueryWithPreviousResult<T>(\n    queryIdOrObservable: string | ObservableQuery<T>,\n  ): {\n    previousResult: any;\n    variables: OperationVariables | undefined;\n    document: DocumentNode;\n  } {\n    let observableQuery: ObservableQuery<T>;\n    if (typeof queryIdOrObservable === 'string') {\n      const { observableQuery: foundObserveableQuery } = this.getQuery(\n        queryIdOrObservable,\n      );\n      invariant(\n        foundObserveableQuery,\n        `ObservableQuery with this id doesn't exist: ${queryIdOrObservable}`\n      );\n      observableQuery = foundObserveableQuery!;\n    } else {\n      observableQuery = queryIdOrObservable;\n    }\n\n    const { variables, query } = observableQuery.options;\n\n    const { data } = this.getCurrentQueryResult(observableQuery, false);\n\n    return {\n      previousResult: data,\n      variables,\n      document: query,\n    };\n  }\n\n  public broadcastQueries(forceResolvers = false) {\n    this.onBroadcast();\n    this.queries.forEach((info, id) => {\n      if (!info.invalidated || !info.listeners) return;\n      info.listeners\n        // it's possible for the listener to be undefined if the query is being stopped\n        // See here for more detail: https://github.com/apollostack/apollo-client/issues/231\n        .filter((x: QueryListener) => !!x)\n        .forEach((listener: QueryListener) => {\n          listener(this.queryStore.get(id), info.newData, forceResolvers);\n        });\n    });\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  private getObservableQueryPromises(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>>[] {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (!observableQuery) return;\n      const fetchPolicy = observableQuery.options.fetchPolicy;\n\n      observableQuery.resetLastResults();\n      if (\n        fetchPolicy !== 'cache-only' &&\n        (includeStandby || fetchPolicy !== 'standby')\n      ) {\n        observableQueryPromises.push(observableQuery.refetch());\n      }\n\n      this.setQuery(queryId, () => ({ newData: null }));\n      this.invalidate(true, queryId);\n    });\n\n    return observableQueryPromises;\n  }\n\n  // Takes a request id, query id, a query document and information associated with the query\n  // and send it to the network interface. Returns\n  // a promise for the result associated with that request.\n  private fetchRequest<T>({\n    requestId,\n    queryId,\n    document,\n    options,\n    fetchMoreForQueryId,\n  }: {\n    requestId: number;\n    queryId: string;\n    document: DocumentNode;\n    options: WatchQueryOptions;\n    fetchMoreForQueryId?: string;\n  }): Promise<FetchResult<T>> {\n    const { variables, context, errorPolicy = 'none', fetchPolicy } = options;\n    let resultFromStore: any;\n    let errorsFromStore: any;\n\n    return new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      let obs: Observable<FetchResult>;\n      let updatedContext = {};\n\n      const clientQuery = this.localState.clientQuery(document);\n      const serverQuery = this.localState.serverQuery(document);\n      if (serverQuery) {\n        const operation = this.buildOperationForLink(serverQuery, variables, {\n          ...context,\n          forceFetch: !this.queryDeduplication,\n        });\n        updatedContext = operation.context;\n        obs = execute(this.deduplicator, operation);\n      } else {\n        updatedContext = this.prepareContext(context);\n        obs = Observable.of({ data: {} });\n      }\n\n      this.fetchQueryRejectFns.set(`fetchRequest:${queryId}`, reject);\n\n      let complete = false;\n      let handlingNext = true;\n\n      const subscriber = {\n        next: async (result: ExecutionResult) => {\n          handlingNext = true;\n          let updatedResult = result;\n\n          // default the lastRequestId to 1\n          const { lastRequestId } = this.getQuery(queryId);\n          if (requestId >= (lastRequestId || 1)) {\n            // Run the query through local client resolvers.\n            if (clientQuery && hasDirectives(['client'], clientQuery)) {\n              updatedResult = await this.localState\n                .runResolvers({\n                  document: clientQuery,\n                  remoteResult: result,\n                  context: updatedContext,\n                  variables,\n                })\n                .catch(error => {\n                  handlingNext = false;\n                  reject(error);\n                  return result;\n                });\n            }\n\n            if (fetchPolicy !== 'no-cache') {\n              try {\n                this.dataStore.markQueryResult(\n                  updatedResult,\n                  document,\n                  variables,\n                  fetchMoreForQueryId,\n                  errorPolicy === 'ignore' || errorPolicy === 'all',\n                );\n              } catch (e) {\n                handlingNext = false;\n                reject(e);\n                return;\n              }\n            } else {\n              this.setQuery(queryId, () => ({\n                newData: { result: updatedResult.data, complete: true },\n              }));\n            }\n\n            this.queryStore.markQueryResult(\n              queryId,\n              updatedResult,\n              fetchMoreForQueryId,\n            );\n\n            this.invalidate(true, queryId, fetchMoreForQueryId);\n\n            this.broadcastQueries();\n          }\n\n          if (updatedResult.errors && errorPolicy === 'none') {\n            handlingNext = false;\n            reject(\n              new ApolloError({\n                graphQLErrors: updatedResult.errors,\n              }),\n            );\n            return;\n          } else if (errorPolicy === 'all') {\n            errorsFromStore = updatedResult.errors;\n          }\n\n          if (fetchMoreForQueryId || fetchPolicy === 'no-cache') {\n            // We don't write fetchMore results to the store because this would overwrite\n            // the original result in case an @connection directive is used.\n            resultFromStore = updatedResult.data;\n          } else {\n            try {\n              // ensure result is combined with data already in store\n              resultFromStore = this.dataStore.getCache().read({\n                variables,\n                query: document,\n                optimistic: false,\n              });\n              // this will throw an error if there are missing fields in\n              // the results which can happen with errors from the server.\n              // tslint:disable-next-line\n            } catch (e) {}\n          }\n\n          handlingNext = false;\n          if (complete) {\n            subscriber.complete();\n          }\n        },\n        error: (error: ApolloError) => {\n          this.fetchQueryRejectFns.delete(`fetchRequest:${queryId}`);\n\n          this.setQuery(queryId, ({ subscriptions }) => ({\n            subscriptions: subscriptions.filter(x => x !== subscription),\n          }));\n\n          reject(error);\n        },\n        complete: () => {\n          if (!handlingNext) {\n            this.fetchQueryRejectFns.delete(`fetchRequest:${queryId}`);\n\n            this.setQuery(queryId, ({ subscriptions }) => ({\n              subscriptions: subscriptions.filter(x => x !== subscription),\n            }));\n\n            resolve({\n              data: resultFromStore,\n              errors: errorsFromStore,\n              loading: false,\n              networkStatus: NetworkStatus.ready,\n              stale: false,\n            });\n          }\n          complete = true;\n        },\n      };\n\n      const subscription = obs.subscribe(subscriber);\n\n      this.setQuery(queryId, ({ subscriptions }) => ({\n        subscriptions: subscriptions.concat([subscription]),\n      }));\n    }).catch(error => {\n      this.fetchQueryRejectFns.delete(`fetchRequest:${queryId}`);\n      throw error;\n    });\n  }\n\n  // Refetches a query given that query's name. Refetches\n  // all ObservableQuery instances associated with the query name.\n  private refetchQueryByName(queryName: string) {\n    const refetchedQueries = this.queryIdsByName[queryName];\n    // early return if the query named does not exist (not yet fetched)\n    // this used to warn but it may be inteneded behavoir to try and refetch\n    // un called queries because they could be on different routes\n    if (refetchedQueries === undefined) return;\n    return Promise.all(\n      refetchedQueries\n        .map(id => this.getQuery(id).observableQuery)\n        .filter(x => !!x)\n        .map((x: ObservableQuery<any>) => x.refetch()),\n    );\n  }\n\n  private generateRequestId() {\n    const requestId = this.idCounter;\n    this.idCounter++;\n    return requestId;\n  }\n\n  private getQuery(queryId: string) {\n    return (\n      this.queries.get(queryId) || {\n        listeners: [],\n        invalidated: false,\n        document: null,\n        newData: null,\n        lastRequestId: null,\n        observableQuery: null,\n        subscriptions: [],\n      }\n    );\n  }\n\n  private setQuery<T extends keyof QueryInfo>(\n    queryId: string,\n    updater: (prev: QueryInfo) => Pick<QueryInfo, T>,\n  ) {\n    const prev = this.getQuery(queryId);\n    const newInfo = { ...prev, ...updater(prev) };\n    this.queries.set(queryId, newInfo);\n  }\n\n  private invalidate(\n    invalidated: boolean,\n    queryId?: string,\n    fetchMoreForQueryId?: string,\n  ) {\n    if (queryId) this.setQuery(queryId, () => ({ invalidated }));\n\n    if (fetchMoreForQueryId) {\n      this.setQuery(fetchMoreForQueryId, () => ({ invalidated }));\n    }\n  }\n\n  private buildOperationForLink(\n    document: DocumentNode,\n    variables: any,\n    extraContext?: any,\n  ) {\n    const cache = this.dataStore.getCache();\n    return {\n      query: cache.transformForLink\n        ? cache.transformForLink(document)\n        : document,\n      variables,\n      operationName: getOperationName(document) || undefined,\n      context: this.prepareContext(extraContext),\n    };\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n\n  public checkInFlight(queryId: string) {\n    const query = this.queryStore.get(queryId);\n\n    return (\n      query &&\n      query.networkStatus !== NetworkStatus.ready &&\n      query.networkStatus !== NetworkStatus.error\n    );\n  }\n\n  // Map from client ID to { interval, options }.\n  private pollingInfoByQueryId = new Map<string, {\n    interval: number;\n    lastPollTimeMs: number;\n    options: WatchQueryOptions;\n  }>();\n\n  private nextPoll: {\n    time: number;\n    timeout: NodeJS.Timeout;\n  } | null = null;\n\n  public startPollingQuery(\n    options: WatchQueryOptions,\n    queryId: string,\n    listener?: QueryListener,\n  ): string {\n    const { pollInterval } = options;\n\n    invariant(\n      pollInterval,\n      'Attempted to start a polling query without a polling interval.',\n    );\n\n    // Do not poll in SSR mode\n    if (!this.ssrMode) {\n      this.pollingInfoByQueryId.set(queryId, {\n        interval: pollInterval!,\n        // Avoid polling until at least pollInterval milliseconds from now.\n        // The -10 is a fudge factor to help with tests that rely on simulated\n        // timeouts via jest.runTimersToTime.\n        lastPollTimeMs: Date.now() - 10,\n        options: {\n          ...options,\n          fetchPolicy: 'network-only',\n        },\n      });\n\n      if (listener) {\n        this.addQueryListener(queryId, listener);\n      }\n\n      this.schedulePoll(pollInterval!);\n    }\n\n    return queryId;\n  }\n\n  public stopPollingQuery(queryId: string) {\n    // Since the master polling interval dynamically adjusts to the contents of\n    // this.pollingInfoByQueryId, stopping a query from polling is as easy as\n    // removing it from the map.\n    this.pollingInfoByQueryId.delete(queryId);\n  }\n\n  // Calling this method ensures a poll will happen within the specified time\n  // limit, canceling any pending polls that would not happen in time.\n  private schedulePoll(timeLimitMs: number) {\n    const now = Date.now();\n\n    if (this.nextPoll) {\n      if (timeLimitMs < this.nextPoll.time - now) {\n        // The next poll will happen too far in the future, so cancel it, and\n        // fall through to scheduling a new timeout.\n        clearTimeout(this.nextPoll.timeout);\n      } else {\n        // The next poll will happen within timeLimitMs, so all is well.\n        return;\n      }\n    }\n\n    this.nextPoll = {\n      // Estimated time when the timeout will fire.\n      time: now + timeLimitMs,\n\n      timeout: setTimeout(() => {\n        this.nextPoll = null;\n        let nextTimeLimitMs = Infinity;\n\n        this.pollingInfoByQueryId.forEach((info, queryId) => {\n          // Pick next timeout according to current minimum interval.\n          if (info.interval < nextTimeLimitMs) {\n            nextTimeLimitMs = info.interval;\n          }\n\n          if (!this.checkInFlight(queryId)) {\n            // If this query was last polled more than interval milliseconds\n            // ago, poll it now. Note that there may be a small delay between\n            // the desired polling time and the actual polling time (equal to\n            // at most the minimum polling interval across all queries), but\n            // that's the tradeoff to batching polling intervals.\n            if (Date.now() - info.lastPollTimeMs >= info.interval) {\n              const updateLastPollTime = () => {\n                info.lastPollTimeMs = Date.now();\n              };\n              this.fetchQuery(queryId, info.options, FetchType.poll).then(\n                // Set info.lastPollTimeMs after the fetch completes, whether\n                // or not it succeeded. Promise.prototype.finally would be nice\n                // here, but we don't have a polyfill for that at the moment,\n                // and this code has historically silenced errors, which is not\n                // the behavior of .finally(updateLastPollTime).\n                updateLastPollTime,\n                updateLastPollTime\n              );\n            }\n          }\n        });\n\n        // If there were no entries in this.pollingInfoByQueryId, then\n        // nextTimeLimitMs will still be Infinity, so this.schedulePoll will\n        // not be called, thus ending the master polling interval.\n        if (isFinite(nextTimeLimitMs)) {\n          this.schedulePoll(nextTimeLimitMs);\n        }\n      }, timeLimitMs),\n    };\n  }\n}\n","import { ExecutionResult, DocumentNode } from 'graphql';\nimport { ApolloCache, Cache, DataProxy } from 'apollo-cache';\n\nimport { QueryStoreValue } from '../data/queries';\nimport {\n  getOperationName,\n  tryFunctionOrLogError,\n  graphQLResultHasError,\n} from 'apollo-utilities';\nimport { MutationQueryReducer } from '../core/types';\n\nexport type QueryWithUpdater = {\n  updater: MutationQueryReducer<Object>;\n  query: QueryStoreValue;\n};\n\nexport interface DataWrite {\n  rootId: string;\n  result: any;\n  document: DocumentNode;\n  operationName: string | null;\n  variables: Object;\n}\n\nexport class DataStore<TSerialized> {\n  private cache: ApolloCache<TSerialized>;\n\n  constructor(initialCache: ApolloCache<TSerialized>) {\n    this.cache = initialCache;\n  }\n\n  public getCache(): ApolloCache<TSerialized> {\n    return this.cache;\n  }\n\n  public markQueryResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n    fetchMoreForQueryId: string | undefined,\n    ignoreErrors: boolean = false,\n  ) {\n    let writeWithErrors = !graphQLResultHasError(result);\n    if (ignoreErrors && graphQLResultHasError(result) && result.data) {\n      writeWithErrors = true;\n    }\n    if (!fetchMoreForQueryId && writeWithErrors) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_QUERY',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markSubscriptionResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n  ) {\n    // the subscription interface should handle not sending us results we no longer subscribe to.\n    // XXX I don't think we ever send in an object with errors, but we might in the future...\n    if (!graphQLResultHasError(result)) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_SUBSCRIPTION',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markMutationInit(mutation: {\n    mutationId: string;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n    optimisticResponse: Object | Function | undefined;\n  }) {\n    if (mutation.optimisticResponse) {\n      let optimistic: Object;\n      if (typeof mutation.optimisticResponse === 'function') {\n        optimistic = mutation.optimisticResponse(mutation.variables);\n      } else {\n        optimistic = mutation.optimisticResponse;\n      }\n\n      const changeFn = () => {\n        this.markMutationResult({\n          mutationId: mutation.mutationId,\n          result: { data: optimistic },\n          document: mutation.document,\n          variables: mutation.variables,\n          updateQueries: mutation.updateQueries,\n          update: mutation.update,\n        });\n      };\n\n      this.cache.recordOptimisticTransaction(c => {\n        const orig = this.cache;\n        this.cache = c;\n\n        try {\n          changeFn();\n        } finally {\n          this.cache = orig;\n        }\n      }, mutation.mutationId);\n    }\n  }\n\n  public markMutationResult(mutation: {\n    mutationId: string;\n    result: ExecutionResult;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n  }) {\n    // Incorporate the result from this mutation into the store\n    if (!graphQLResultHasError(mutation.result)) {\n      const cacheWrites: Cache.WriteOptions[] = [];\n      cacheWrites.push({\n        result: mutation.result.data,\n        dataId: 'ROOT_MUTATION',\n        query: mutation.document,\n        variables: mutation.variables,\n      });\n\n      if (mutation.updateQueries) {\n        Object.keys(mutation.updateQueries)\n          .filter(id => mutation.updateQueries[id])\n          .forEach(queryId => {\n            const { query, updater } = mutation.updateQueries[queryId];\n            // Read the current query result from the store.\n            const { result: currentQueryResult, complete } = this.cache.diff({\n              query: query.document,\n              variables: query.variables,\n              returnPartialData: true,\n              optimistic: false,\n            });\n\n            if (!complete) {\n              return;\n            }\n\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = tryFunctionOrLogError(() =>\n              updater(currentQueryResult, {\n                mutationResult: mutation.result,\n                queryName: getOperationName(query.document) || undefined,\n                queryVariables: query.variables,\n              }),\n            );\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: query.document,\n                variables: query.variables,\n              });\n            }\n          });\n      }\n\n      this.cache.performTransaction(c => {\n        cacheWrites.forEach(write => c.write(write));\n      });\n\n      // If the mutation has some writes associated with it then we need to\n      // apply those writes to the store by running this reducer again with a\n      // write action.\n      const update = mutation.update;\n      if (update) {\n        this.cache.performTransaction(c => {\n          tryFunctionOrLogError(() => update(c, mutation.result));\n        });\n      }\n    }\n  }\n\n  public markMutationComplete({\n    mutationId,\n    optimisticResponse,\n  }: {\n    mutationId: string;\n    optimisticResponse?: any;\n  }) {\n    if (!optimisticResponse) return;\n    this.cache.removeOptimistic(mutationId);\n  }\n\n  public markUpdateQueryResult(\n    document: DocumentNode,\n    variables: any,\n    newResult: any,\n  ) {\n    this.cache.write({\n      result: newResult,\n      dataId: 'ROOT_QUERY',\n      variables,\n      query: document,\n    });\n  }\n\n  public reset(): Promise<void> {\n    return this.cache.reset();\n  }\n}\n","export const version = \"2.5.1\"","import {\n  ApolloLink,\n  Operation,\n  NextLink,\n  FetchResult,\n  GraphQLRequest,\n  execute,\n} from 'apollo-link';\nimport { ExecutionResult, DocumentNode } from 'graphql';\nimport { ApolloCache, DataProxy } from 'apollo-cache';\nimport {\n  removeConnectionDirectiveFromDocument,\n} from 'apollo-utilities';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { QueryManager } from './core/QueryManager';\nimport {\n  ApolloQueryResult,\n  OperationVariables,\n  Resolvers,\n} from './core/types';\nimport { ObservableQuery } from './core/ObservableQuery';\nimport { LocalState, FragmentMatcher } from './core/LocalState';\nimport { Observable } from './util/Observable';\n\nimport {\n  QueryBaseOptions,\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ModifiableWatchQueryOptions,\n  MutationBaseOptions,\n} from './core/watchQueryOptions';\n\nimport { DataStore } from './data/store';\n\nimport { version } from './version';\n\n\nexport interface DefaultOptions {\n  watchQuery?: ModifiableWatchQueryOptions;\n  query?: QueryBaseOptions;\n  mutate?: MutationBaseOptions;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport type ApolloClientOptions<TCacheShape> = {\n  link?: ApolloLink;\n  cache: ApolloCache<TCacheShape>;\n  ssrForceFetchDelay?: number;\n  ssrMode?: boolean;\n  connectToDevTools?: boolean;\n  queryDeduplication?: boolean;\n  defaultOptions?: DefaultOptions;\n  resolvers?: Resolvers | Resolvers[];\n  typeDefs?: string | string[] | DocumentNode | DocumentNode[];\n  fragmentMatcher?: FragmentMatcher;\n  name?: string;\n  version?: string;\n};\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over a {@link NetworkInterface} instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through {@link Observable} instances.\n */\nexport default class ApolloClient<TCacheShape> implements DataProxy {\n  public link: ApolloLink;\n  public store: DataStore<TCacheShape>;\n  public cache: ApolloCache<TCacheShape>;\n  public queryManager: QueryManager<TCacheShape> | undefined;\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions = {};\n  public readonly typeDefs: ApolloClientOptions<TCacheShape>['typeDefs'];\n\n  private devToolsHookCb: Function;\n  private proxy: ApolloCache<TCacheShape> | undefined;\n  private ssrMode: boolean;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TCacheShape>;\n\n  /**\n   * Constructs an instance of {@link ApolloClient}.\n   *\n   * @param link The {@link ApolloLink} over which GraphQL documents will be resolved into a response.\n   *\n   * @param cache The initial cache to use in the data store.\n   *\n   * @param ssrMode Determines whether this is being run in Server Side Rendering (SSR) mode.\n   *\n   * @param ssrForceFetchDelay Determines the time interval before we force fetch queries for a\n   * server side render.\n   *\n   * @param queryDeduplication If set to false, a query will still be sent to the server even if a query\n   * with identical parameters (query, variables, operationName) is already in flight.\n   *\n   * @param defaultOptions Used to set application wide defaults for the\n   *                       options supplied to `watchQuery`, `query`, or\n   *                       `mutate`.\n   *\n   * @param name A custom name that can be used to identify this client, when\n   *             using Apollo client awareness features. E.g. \"iOS\".\n   *\n   * @param version A custom version that can be used to identify this client,\n   *                when using Apollo client awareness features. This is the\n   *                version of your client, which you may want to increment on\n   *                new builds. This is NOT the version of Apollo Client that\n   *                you are using.\n   */\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    const {\n      cache,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      connectToDevTools,\n      queryDeduplication = true,\n      defaultOptions,\n      resolvers,\n      typeDefs,\n      fragmentMatcher,\n      name: clientAwarenessName,\n      version: clientAwarenessVersion,\n    } = options;\n\n    let { link } = options;\n\n    // If a link hasn't been defined, but local state resolvers have been set,\n    // setup a default empty link.\n    if (!link && resolvers) {\n      link = ApolloLink.empty();\n    }\n\n    if (!link || !cache) {\n      throw new InvariantError(`\n        In order to initialize Apollo Client, you must specify link & cache properties on the config object.\n        This is part of the required upgrade when migrating from Apollo Client 1.0 to Apollo Client 2.0.\n        For more information, please visit:\n          https://www.apollographql.com/docs/react/basics/setup.html\n        to help you get started.\n      `);\n    }\n\n    const supportedCache = new Map<DocumentNode, DocumentNode>();\n    const supportedDirectives = new ApolloLink(\n      (operation: Operation, forward: NextLink) => {\n        let result = supportedCache.get(operation.query);\n        if (!result) {\n          result = removeConnectionDirectiveFromDocument(operation.query);\n          supportedCache.set(operation.query, result);\n          supportedCache.set(result, result);\n        }\n        operation.query = result;\n        return forward(operation);\n      },\n    );\n\n    // remove apollo-client supported directives\n    this.link = supportedDirectives.concat(link);\n    this.cache = cache;\n    this.store = new DataStore(cache);\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.ssrMode = ssrMode;\n    this.defaultOptions = defaultOptions || {};\n    this.typeDefs = typeDefs;\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay,\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    // Attach the client instance to window to let us be found by chrome devtools, but only in\n    // development mode\n    const defaultConnectToDevTools =\n      process.env.NODE_ENV !== 'production' &&\n      typeof window !== 'undefined' &&\n      !(window as any).__APOLLO_CLIENT__;\n\n    if (\n      typeof connectToDevTools === 'undefined'\n        ? defaultConnectToDevTools\n        : connectToDevTools && typeof window !== 'undefined'\n    ) {\n      (window as any).__APOLLO_CLIENT__ = this;\n    }\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && process.env.NODE_ENV !== 'production') {\n      hasSuggestedDevtools = true;\n      if (\n        typeof window !== 'undefined' &&\n        window.document &&\n        window.top === window.self\n      ) {\n        // First check if devtools is not installed\n        if (\n          typeof (window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === 'undefined'\n        ) {\n          // Only for Chrome\n          if (\n            window.navigator &&\n            window.navigator.userAgent &&\n            window.navigator.userAgent.indexOf('Chrome') > -1\n          ) {\n            // tslint:disable-next-line\n            console.debug(\n              'Download the Apollo DevTools ' +\n                'for a better development experience: ' +\n                'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm',\n            );\n          }\n        }\n      }\n    }\n\n    this.version = version;\n\n    if (clientAwarenessName) {\n      this.clientAwareness.name = clientAwarenessName;\n    }\n\n    if (clientAwarenessVersion) {\n      this.clientAwareness.version = clientAwarenessVersion;\n    }\n\n    this.localState = new LocalState({\n      cache,\n      client: this,\n      resolvers,\n      fragmentMatcher,\n    });\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  public stop() {\n    if (this.queryManager) {\n      this.queryManager.stop();\n    }\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an {@link ObservableQuery}. We can subscribe to this {@link ObservableQuery} and\n   * receive updated results through a GraphQL observer when the cache store changes.\n   * <p /><p />\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   * <p /><p />\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifer, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   * <p /><p />\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   * <p /><p />\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<T = any, TVariables = OperationVariables>(\n    options: WatchQueryOptions<TVariables>,\n  ): ObservableQuery<T, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = {\n        ...this.defaultOptions.watchQuery,\n        ...options,\n      } as WatchQueryOptions<TVariables>;\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === 'network-only' ||\n        options.fetchPolicy === 'cache-and-network')\n    ) {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.initQueryManager().watchQuery<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a {@link Promise} which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options An object of type {@link QueryOptions} that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<T = any, TVariables = OperationVariables>(\n    options: QueryOptions<TVariables>,\n  ): Promise<ApolloQueryResult<T>> {\n    if (this.defaultOptions.query) {\n      options = { ...this.defaultOptions.query, ...options } as QueryOptions<\n        TVariables\n      >;\n    }\n\n    invariant(\n      options.fetchPolicy !== 'cache-and-network',\n      'cache-and-network fetchPolicy can only be used with watchQuery'\n    );\n\n    // XXX Overwriting options is probably not the best way to do this long\n    // term...\n    if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.initQueryManager().query<T>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * {@link Promise} which is either resolved with the resulting data or rejected with an\n   * error.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<T = any, TVariables = OperationVariables>(\n    options: MutationOptions<T, TVariables>,\n  ): Promise<FetchResult<T>> {\n    if (this.defaultOptions.mutate) {\n      options = {\n        ...this.defaultOptions.mutate,\n        ...options,\n      } as MutationOptions<T, TVariables>;\n    }\n\n    return this.initQueryManager().mutate<T>(options);\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * {@link Observable} which either emits received data or an error.\n   */\n  public subscribe<T = any, TVariables = OperationVariables>(\n    options: SubscriptionOptions<TVariables>,\n  ): Observable<T> {\n    return this.initQueryManager().startGraphQLSubscription<T>(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.initProxy().readQuery<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.initProxy().readFragment<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    const result = this.initProxy().writeQuery<TData, TVariables>(options);\n    this.initQueryManager().broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    const result = this.initProxy().writeFragment<TData, TVariables>(options);\n    this.initQueryManager().broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Sugar for writeQuery & writeFragment\n   * This method will construct a query from the data object passed in.\n   * If no id is supplied, writeData will write the data to the root.\n   * If an id is supplied, writeData will write a fragment to the object\n   * specified by the id in the store.\n   *\n   * Since you aren't passing in a query to check the shape of the data,\n   * you must pass in an object that conforms to the shape of valid GraphQL data.\n   */\n  public writeData<TData = any>(\n    options: DataProxy.WriteDataOptions<TData>,\n  ): void {\n    const result = this.initProxy().writeData<TData>(options);\n    this.initQueryManager().broadcastQueries();\n    return result;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(payload: GraphQLRequest): Observable<ExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * This initializes the query manager that tracks queries and the cache\n   */\n  public initQueryManager(): QueryManager<TCacheShape> {\n    if (!this.queryManager) {\n      this.queryManager = new QueryManager({\n        link: this.link,\n        store: this.store,\n        queryDeduplication: this.queryDeduplication,\n        ssrMode: this.ssrMode,\n        clientAwareness: this.clientAwareness,\n        localState: this.localState,\n        onBroadcast: () => {\n          if (this.devToolsHookCb) {\n            this.devToolsHookCb({\n              action: {},\n              state: {\n                queries: this.queryManager\n                  ? this.queryManager.queryStore.getStore()\n                  : {},\n                mutations: this.queryManager\n                  ? this.queryManager.mutationStore.getStore()\n                  : {},\n              },\n              dataWithOptimisticResults: this.cache.extract(true),\n            });\n          }\n        },\n      });\n    }\n    return this.queryManager;\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. Youâ€™ve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() => {\n        return this.queryManager\n          ? this.queryManager.clearStore()\n          : Promise.resolve(null);\n      })\n      .then(() => Promise.all(this.resetStoreCallbacks.map(fn => fn())))\n      .then(() => {\n        return this.queryManager && this.queryManager.reFetchObservableQueries\n          ? this.queryManager.reFetchObservableQueries()\n          : Promise.resolve(null);\n      });\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<void | null> {\n    const { queryManager } = this;\n    return Promise.resolve()\n      .then(() => Promise.all(this.clearStoreCallbacks.map(fn => fn())))\n      .then(\n        () =>\n          queryManager ? queryManager.clearStore() : Promise.resolve(null),\n      );\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>[]> | Promise<null> {\n    return this.queryManager\n      ? this.queryManager.reFetchObservableQueries(includeStandby)\n      : Promise.resolve(null);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.initProxy().extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.initProxy().restore(serializedState);\n  }\n\n  /**\n   * Add additional local resolvers.\n   */\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.addResolvers(resolvers);\n  }\n\n  /**\n   * Set (override existing) local resolvers.\n   */\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.setResolvers(resolvers);\n  }\n\n  /**\n   * Get all registered local resolvers.\n   */\n  public getResolvers() {\n    return this.localState.getResolvers();\n  }\n\n  /**\n   * Set a custom local state fragment matcher.\n   */\n  public setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  }\n\n  /**\n   * Initializes a data proxy for this client instance if one does not already\n   * exist and returns either a previously initialized proxy instance or the\n   * newly initialized instance.\n   */\n  private initProxy(): ApolloCache<TCacheShape> {\n    if (!this.proxy) {\n      this.initQueryManager();\n      this.proxy = this.cache;\n    }\n    return this.proxy;\n  }\n}\n"],"names":["tslib_1.__extends","LinkObservable","tslib_1.__assign","Deduplicator"],"mappings":"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"}